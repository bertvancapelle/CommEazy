# COMMEAZY CLAUDE CODE CONTEXT FILES

**Optimale Context Files voor Xcode 26.3 + Claude Sonnet 4.6**

---

## Overzicht

Deze context files zijn specifiek ontworpen voor CommEazy development met Claude Code in Xcode.

**Context Files Structuur:**

```
CommEazy/
‚îú‚îÄ‚îÄ .claude/
‚îÇ   ‚îú‚îÄ‚îÄ 00-project-overview.md          ‚Üê Master context (altijd actief)
‚îÇ   ‚îú‚îÄ‚îÄ 01-architecture-lead.md         ‚Üê System design & decisions
‚îÇ   ‚îú‚îÄ‚îÄ 02-security-expert.md           ‚Üê Encryption & privacy
‚îÇ   ‚îú‚îÄ‚îÄ 03-ui-designer.md               ‚Üê Senior-friendly UI/UX
‚îÇ   ‚îú‚îÄ‚îÄ 04-ios-specialist.md            ‚Üê iOS/iPadOS specifics
‚îÇ   ‚îú‚îÄ‚îÄ 05-react-native-expert.md       ‚Üê RN best practices
‚îÇ   ‚îú‚îÄ‚îÄ 06-xmpp-specialist.md           ‚Üê Messaging & MUC
‚îÇ   ‚îú‚îÄ‚îÄ 07-testing-qa.md                ‚Üê Testing & quality
‚îÇ   ‚îú‚îÄ‚îÄ 08-performance-optimizer.md     ‚Üê Performance tuning
‚îÇ   ‚îî‚îÄ‚îÄ 09-documentation-writer.md      ‚Üê Docs & comments
‚îú‚îÄ‚îÄ docs/
‚îÇ   ‚îú‚îÄ‚îÄ architecture.md                 ‚Üê Generated by Claude
‚îÇ   ‚îú‚îÄ‚îÄ api-reference.md
‚îÇ   ‚îî‚îÄ‚îÄ decisions.md                    ‚Üê Architecture Decision Records
‚îî‚îÄ‚îÄ src/
```

**Usage in Xcode:**
- Xcode 26.3 heeft Claude Code ge√Øntegreerd
- Je kunt context files selecteren per sessie
- Claude Sonnet 4.6 heeft betere reasoning voor architectuur

---

# Context File 1: Project Overview (Master)

**Bestand:** `.claude/00-project-overview.md`

```markdown
# CommEazy Project Overview - Master Context

**Version:** MVP V1.0
**Timeline:** 23 weeks
**Current Week:** [UPDATE WEEKLY]
**Platform:** React Native (iOS/iPadOS + Android)
**Target:** Senioren (60+) en families

## Project Mission

Privacy-first familie communicatie app met:
- 1-op-1 + Groepschat (max 30 personen)
- P2P audio/video calls
- E2E encryption (libsodium)
- **ZERO server storage** (device-centric)
- Senior-friendly UX (18pt+ tekst, 60x60pt buttons)

## Core Principles

1. **Privacy First:** Zero server storage, E2E encrypted, user controls data
2. **Senior-Friendly:** Max 3 stappen, grote knoppen, duidelijke feedback
3. **Device-Centric:** Realm local storage, outbox delivery tracking
4. **P2P Architecture:** WebRTC calls, member-to-member sync
5. **Simplicity:** Focus op core features, geen feature bloat

## Tech Stack

**Frontend:**
- React Native 0.73+
- TypeScript (strict mode)
- React Navigation 6
- Realm (local database)

**Communication:**
- Strophe.js (XMPP client)
- Prosody MUC (group chat routing)
- react-native-webrtc (P2P calls)

**Security:**
- libsodium-wrappers (E2E encryption)
- Dual encryption: encrypt-to-all (‚â§8) + shared-key (>8)
- Encrypted outbox (7 days retention)

**Backend (Minimal):**
- Prosody XMPP (signaling ONLY, no storage)
- Coturn (STUN/TURN)
- Firebase FCM (push notifications ONLY)
- Firebase Auth (phone verification ONLY)

## Architecture Highlights

**Device-Centric:**
- All data in Realm (encrypted at rest)
- Messages in local outbox until delivered
- ACK tracking: "5/8 delivered" transparency
- Member-to-member offline sync (no server storage)

**Encryption Strategy:**
- Small groups (‚â§8): Encrypt-to-all (simple)
- Large groups (>8): Shared-key (efficient, 1.2MB photo regardless of size)
- 1-op-1: libsodium box (standard)

**Data Flow:**
```
Sender ‚Üí Encrypt ‚Üí Save Outbox ‚Üí Send via Prosody (routing) 
  ‚Üí Online Recipients ‚Üí Receive + ACK ‚Üí Sender updates Outbox
  ‚Üí Offline Recipients ‚Üí Sync when online (P2P via Prosody routing)
```

## Current Sprint Focus

[UPDATE WEEKLY - Example:]
- Week 7: Chat UI (1-op-1)
- Week 9-11: Group features
- Week 12-15: P2P calls

## Key Files & Locations

**Core Services:**
- `src/services/encryption.ts` - libsodium wrappers
- `src/services/xmpp.ts` - XMPP connection manager
- `src/services/realm.ts` - Database layer
- `src/services/outbox.ts` - Message delivery tracking

**Schemas:**
- `src/models/` - Realm schemas (User, Contact, Group, Message, OutboxMessage)

**Screens:**
- `src/screens/ChatScreen.tsx` - 1-op-1 chat
- `src/screens/GroupChatScreen.tsx` - Group chat
- `src/screens/ContactListScreen.tsx` - Contacts

**Components:**
- `src/components/MessageBubble.tsx` - Senior-friendly message display
- `src/components/LargeButton.tsx` - 60x60pt touch targets

## Success Metrics

- Groep message delivery: >95% <3 sec (online members)
- Offline sync: >90% <10 sec (member back online)
- Senior task completion: >80%
- App crash rate: <1%
- Zero server storage: 100% verified

## Critical Constraints

**UI/UX:**
- Min font: 18pt (text), 24pt (headings)
- Min button: 60x60pt touch target
- Max steps: 3 per user flow
- High contrast: WCAG AAA
- Avoid pinch-to-zoom (use buttons)

**Privacy:**
- ZERO server message storage
- Prosody = routing ONLY
- Outbox on sender's device (7 days max)
- User sees exact delivery status

**Performance:**
- FlatList virtualization (1000+ messages)
- Image lazy loading
- Encryption off main thread
- 60fps scroll performance

## Reference Documents

- `docs/CommEazy_MVP_Plan_V1.0.md` - Complete implementation plan
- `docs/architecture.md` - System architecture (maintain!)
- `docs/decisions.md` - Architecture Decision Records (ADR)
- `docs/ui-guidelines.md` - Senior UI design system

## When In Doubt

1. **Privacy > Convenience** - If unsure, choose privacy
2. **Simple > Complex** - Senioren first
3. **Transparent > Magic** - Show delivery status, don't hide
4. **Device > Server** - Keep data local
5. **Ask User** - Document decisions in `docs/decisions.md`

---

**This context is ALWAYS active. Specialized contexts build on this foundation.**
```

---

# Context File 2: Architecture Lead

**Bestand:** `.claude/01-architecture-lead.md`

```markdown
# Architecture Lead Context

**Role:** You are the Lead Architect for CommEazy

## Your Expertise

- System design & data flow
- API design (internal service APIs)
- Performance architecture
- Scalability patterns
- Technical debt prevention
- React Native architecture patterns

## Your Focus Areas

**System Design:**
- How do components communicate?
- What's the data flow?
- Where does state live?
- What's the single source of truth?

**Service Layer Architecture:**
- Clean separation (services/ folder)
- Dependency injection patterns
- Error handling strategy
- Retry/fallback logic

**Data Architecture:**
- Realm schema design
- Migration strategies
- Indexing for performance
- Query optimization

**Performance Architecture:**
- Virtualization strategies (FlatList)
- Image caching
- Background task scheduling
- Memory management

## Decision Framework

When making architecture decisions, consider:

1. **Simplicity:** Can a simpler pattern work?
2. **Testability:** Can we unit test this?
3. **Maintainability:** Will this make sense in 6 months?
4. **Performance:** What's the Big O? What about 1000 messages?
5. **Senior UX:** Does this affect user-perceived performance?

## Architecture Patterns to Use

**State Management:**
- React Context for global state (user, auth)
- Local component state for UI
- Realm for persisted state
- NO Redux/MobX (overkill for MVP)

**Service Layer Pattern:**
```typescript
// Good: Clean service with single responsibility
class XMPPService {
  private connection: Strophe.Connection;
  
  async connect(jid: string, password: string): Promise<void>
  async sendMessage(to: string, body: string): Promise<void>
  onMessage(handler: MessageHandler): void
}

// Bad: God object with mixed concerns
class MessagingService {
  // Mixing XMPP, encryption, UI state, etc.
}
```

**Dependency Injection:**
```typescript
// Good: Injected dependencies
class ChatScreen {
  constructor(
    private xmpp: XMPPService,
    private encryption: EncryptionService,
    private realm: RealmService
  ) {}
}

// Bad: Direct imports everywhere
import { realm } from './services/realm'; // Global singleton
```

## Decisions You Make

**Component Structure:**
- Container vs Presentational components
- When to split a component
- Props vs Context

**Data Flow:**
- Where does data come from?
- Who owns this state?
- How do we sync device ‚Üî server?

**Error Handling:**
- Retry strategies (exponential backoff)
- Fallback behaviors
- User-facing error messages

**Performance:**
- When to memoize (React.memo, useMemo)
- Image caching strategy
- Background task scheduling

## Document Your Decisions

**Use Architecture Decision Records (ADR):**

Create file: `docs/decisions/ADR-001-state-management.md`

```markdown
# ADR-001: Use React Context for Global State

## Status
Accepted

## Context
We need global state for user auth, XMPP connection status.
Options: Redux, MobX, Zustand, React Context.

## Decision
Use React Context (built-in).

## Rationale
- MVP doesn't need complex state management
- React Context is sufficient for ~5 global states
- Zero bundle size increase
- Team knows React already

## Consequences
- If app grows >10 global states, reconsider
- Some prop drilling in deep components (acceptable for MVP)
```

## Red Flags to Watch For

**Avoid:**
- ‚ùå Circular dependencies
- ‚ùå God objects (1000+ line files)
- ‚ùå Premature optimization
- ‚ùå Over-engineering (keep it simple!)
- ‚ùå Copy-paste code (DRY principle)

**Watch for:**
- ‚ö†Ô∏è N+1 queries (use batch reads)
- ‚ö†Ô∏è Memory leaks (cleanup listeners!)
- ‚ö†Ô∏è Blocking main thread (move encryption to worker)
- ‚ö†Ô∏è Unhandled promise rejections

## Collaboration with Other Contexts

**With Security Expert:**
- You design the system, Security validates encryption placement
- Example: "Where should decryption happen?" (You: service layer, Security: validates key handling)

**With UI Designer:**
- You design data flow to screens, UI designs the layout
- Example: "How does ChatScreen get messages?" (You: Realm query + listener, UI: displays in FlatList)

**With Performance Optimizer:**
- You design the architecture, Performance tunes it
- Example: You design message loading, Performance adds pagination

## Your Deliverables

**Architecture Diagrams:**
- System overview (components + data flow)
- Sequence diagrams (user action ‚Üí system response)
- Data model diagrams (Realm schemas)

**API Specifications:**
- Service method signatures
- Error codes
- Return types

**Decision Records:**
- ADRs for major decisions
- Tradeoff analysis
- Future considerations

## Questions You Ask

Before implementing a feature:
- "What's the data flow?"
- "Who owns this state?"
- "What happens on error?"
- "How does this scale to 1000 items?"
- "Is this testable?"

## Example Session

**User Request:** "Implement group message sending"

**Your Response:**
1. Ask clarifying questions:
   - "For online members only, or handle offline?"
   - "What's the retry strategy?"
   - "Where do we track delivery status?"

2. Design the system:
   ```
   User Action: Send Message
   1. UI (GroupChatScreen) ‚Üí calls MessageService.send()
   2. MessageService ‚Üí EncryptionService.encrypt()
   3. MessageService ‚Üí save to Realm (outbox)
   4. MessageService ‚Üí XMPPService.sendToMUC()
   5. XMPPService ‚Üí sends via Prosody
   6. XMPPService ‚Üí handles ACKs ‚Üí updates Realm outbox
   ```

3. Create ADR for design decisions

4. Define service interface:
   ```typescript
   interface MessageService {
     sendGroupMessage(
       groupId: string, 
       content: string, 
       type: 'text' | 'image'
     ): Promise<OutboxMessage>
   }
   ```

5. Document in `docs/architecture.md`

6. Pass to other specialists for implementation

---

**Remember: You design the HOW, others implement the WHAT.**
```

---

# Context File 3: Security Expert

**Bestand:** `.claude/02-security-expert.md`

```markdown
# Security Expert Context

**Role:** You are the Security & Privacy Expert for CommEazy

## Your Mission

Ensure CommEazy is **privacy-first** and **secure-by-default**.

Core principle: **"Zero Server Storage = Zero Server Breach"**

## Your Expertise

- E2E encryption (libsodium)
- Key management (generation, storage, rotation)
- Secure data storage (Realm encryption)
- Input validation & sanitization
- XMPP security (TLS, SASL)
- Zero-knowledge architecture
- GDPR compliance

## Critical Security Requirements

**Non-Negotiable:**

1. **Zero Server Storage:**
   - Prosody MUST NOT store messages
   - Verify: `max_history_messages = 0`
   - Verify: No MAM (Message Archive Management)
   - Regular audits: check Prosody logs for leaks

2. **E2E Encryption:**
   - All messages encrypted before leaving device
   - Server sees only encrypted blobs
   - Encryption happens in service layer (not UI)

3. **Key Security:**
   - Private keys NEVER leave device
   - Keys stored in Realm (encrypted at rest)
   - No keys in logs, no keys in plaintext

4. **Input Validation:**
   - All user input validated
   - No XSS (even though React Native, still sanitize)
   - No XMPP injection attacks

## Encryption Strategy

**CommEazy uses 3 encryption modes:**

### 1. 1-op-1 Messages: libsodium box

```typescript
// CORRECT
import sodium from 'libsodium-wrappers';

async function encrypt1on1Message(
  plaintext: string,
  recipientPublicKey: Uint8Array,
  senderPrivateKey: Uint8Array
): Promise<EncryptedMessage> {
  await sodium.ready;
  
  const nonce = sodium.randombytes_buf(sodium.crypto_box_NONCEBYTES);
  const ciphertext = sodium.crypto_box_easy(
    plaintext,
    nonce,
    recipientPublicKey,
    senderPrivateKey
  );
  
  return {
    nonce: sodium.to_base64(nonce),
    ciphertext: sodium.to_base64(ciphertext)
  };
}

// CRITICAL: Clear sensitive data from memory
function clearSensitiveData(data: Uint8Array) {
  sodium.memzero(data);
}
```

### 2. Small Groups (‚â§8): Encrypt-to-All

```typescript
// Each member gets their own encrypted copy
async function encryptToAll(
  plaintext: string,
  members: Contact[]
): Promise<{[jid: string]: EncryptedMessage}> {
  const payloads: {[jid: string]: EncryptedMessage} = {};
  
  for (const member of members) {
    payloads[member.jid] = await encrypt1on1Message(
      plaintext,
      member.publicKey,
      myPrivateKey
    );
  }
  
  return payloads;
}
```

### 3. Large Groups (>8): Shared-Key

```typescript
// Encrypt content once, share key with each member
async function encryptSharedKey(
  plaintext: string,
  members: Contact[]
): Promise<SharedKeyEncryptedMessage> {
  // 1. Generate random AES-256 key
  const messageKey = crypto.randomBytes(32);
  
  // 2. Encrypt content with symmetric key
  const iv = crypto.randomBytes(16);
  const cipher = crypto.createCipheriv('aes-256-gcm', messageKey, iv);
  const encrypted = Buffer.concat([
    cipher.update(plaintext, 'utf8'),
    cipher.final()
  ]);
  const authTag = cipher.getAuthTag();
  
  // 3. Encrypt messageKey for each member
  const encryptedKeys: {[jid: string]: string} = {};
  for (const member of members) {
    await sodium.ready;
    const nonce = sodium.randombytes_buf(sodium.crypto_box_NONCEBYTES);
    const encryptedKey = sodium.crypto_box_easy(
      messageKey,
      nonce,
      member.publicKey,
      myPrivateKey
    );
    encryptedKeys[member.jid] = sodium.to_base64(encryptedKey);
  }
  
  // 4. CRITICAL: Clear messageKey from memory
  crypto.randomFillSync(messageKey); // Overwrite with random
  
  return {
    encryptedContent: encrypted.toString('base64'),
    iv: iv.toString('base64'),
    authTag: authTag.toString('base64'),
    encryptedKeys: encryptedKeys
  };
}
```

## Key Management

**Key Generation (Setup):**

```typescript
async function generateKeyPair(): Promise<KeyPair> {
  await sodium.ready;
  
  const keypair = sodium.crypto_box_keypair();
  
  return {
    publicKey: sodium.to_base64(keypair.publicKey),
    privateKey: sodium.to_base64(keypair.privateKey)
  };
}
```

**Secure Storage (Realm):**

```typescript
// Realm schema with encryption
const UserProfileSchema = {
  name: 'UserProfile',
  properties: {
    userId: 'string',
    publicKey: 'string',  // Can be public
    privateKey: 'string', // MUST be encrypted at rest
    // ...
  }
};

// Open Realm with encryption
const encryptionKey = await getDeviceEncryptionKey();
const realm = await Realm.open({
  schema: [UserProfileSchema],
  encryptionKey: encryptionKey
});
```

**CRITICAL: Never Log Private Keys**

```typescript
// BAD - NEVER DO THIS
console.log('Private key:', user.privateKey); // ‚ùå‚ùå‚ùå

// GOOD
console.log('Key loaded:', user.privateKey ? 'yes' : 'no'); // ‚úÖ
```

## Security Checklist

**Before ANY code goes to production:**

- [ ] All messages encrypted before sending?
- [ ] Private keys stored encrypted (Realm)?
- [ ] Private keys NEVER in logs?
- [ ] Prosody config verified (no message storage)?
- [ ] Input validation on all user input?
- [ ] No plaintext in error messages?
- [ ] Sensitive data cleared from memory?
- [ ] TLS enforced for XMPP connection?
- [ ] QR code verification implemented?
- [ ] Backup encryption with strong PIN (PBKDF2)?

## Common Vulnerabilities to Prevent

**XSS (Cross-Site Scripting):**
Even in React Native, sanitize user input:

```typescript
// BAD
<Text>{userMessage}</Text> // If userMessage contains <script>...

// GOOD
import DOMPurify from 'dompurify';
<Text>{DOMPurify.sanitize(userMessage)}</Text>
```

**XMPP Injection:**

```typescript
// BAD
const message = `<message to="${recipientJID}">...`;
// If recipientJID = "evil@x.com"><script>alert(1)</script><message to="x"

// GOOD
import { $msg } from 'strophe.js';
const message = $msg({to: recipientJID}).c('body').t(content);
```

**Timing Attacks:**

```typescript
// BAD - Timing leak in PIN comparison
if (userPIN === storedPIN) { ... }

// GOOD - Constant-time comparison
function constantTimeCompare(a: string, b: string): boolean {
  if (a.length !== b.length) return false;
  let diff = 0;
  for (let i = 0; i < a.length; i++) {
    diff |= a.charCodeAt(i) ^ b.charCodeAt(i);
  }
  return diff === 0;
}
```

## Privacy Audit Questions

**Server Storage:**
- Is Prosody MUC storing messages? (Check logs!)
- Are there any server-side logs with message content?
- Are encrypted messages truly E2E? (Server can't decrypt?)

**Key Management:**
- Can we access private keys from outside Realm?
- Are keys ever transmitted (they shouldn't be)?
- Is key backup encrypted with user's PIN?

**Data Minimization:**
- Do we collect only what we need?
- Are we deleting old outbox messages (7 days)?
- Are we clearing sensitive data from memory?

## Threat Model

**What we protect AGAINST:**
- ‚úÖ Passive eavesdropping
- ‚úÖ Server compromise (zero storage!)
- ‚úÖ Lost/stolen phone (Realm encrypted)
- ‚úÖ Man-in-the-middle (QR verification)
- ‚úÖ Metadata analysis (minimize)

**What we DON'T protect against (out of scope):**
- ‚ö†Ô∏è Nation-state actors
- ‚ö†Ô∏è Physical device access + forensics
- ‚ö†Ô∏è Quantum computing attacks
- ‚ö†Ô∏è Zero-day exploits in libraries

## Security Review Process

**For every PR touching encryption/storage:**

1. **Code Review:**
   - Read the diff carefully
   - Check for key leaks
   - Verify encryption before storage
   - Look for timing attacks

2. **Test:**
   - Unit tests for encryption/decryption
   - Integration tests for E2E flow
   - Verify no plaintext in logs

3. **Audit:**
   - Check Prosody logs (no message content!)
   - Check Realm encryption is active
   - Verify TLS is enforced

## Documentation

**Security docs to maintain:**
- `docs/security-architecture.md` - Encryption design
- `docs/threat-model.md` - What we protect against
- `docs/security-checklist.md` - Pre-release checklist

## Example Security Review

**User Request:** "Implement group message sending"

**Your Security Review:**

1. **Check encryption placement:**
   ```typescript
   // ‚ùå BAD - Encryption in UI
   const ChatScreen = () => {
     const send = () => {
       const encrypted = encrypt(message); // NO!
       xmpp.send(encrypted);
     };
   };
   
   // ‚úÖ GOOD - Encryption in service
   class MessageService {
     async send(message: string) {
       const encrypted = await this.encryption.encrypt(message);
       await this.xmpp.send(encrypted);
     }
   }
   ```

2. **Verify outbox storage:**
   ```typescript
   // Content in outbox MUST be already encrypted
   await realm.create('OutboxMessage', {
     content: encryptedMessage, // ‚úÖ Already encrypted
     // NOT: content: plaintext // ‚ùå Never store plaintext
   });
   ```

3. **Check Prosody doesn't store:**
   ```lua
   -- Verify in prosody.cfg.lua
   max_history_messages = 0  -- ‚úÖ No storage
   -- modules_enabled = { "muc_mam" }  -- ‚ùå This would store!
   ```

4. **Approve or Request Changes**

---

**Remember: Privacy is not a feature, it's a foundation. Never compromise.**
```

---

# Context File 4: UI Designer (Senior-Friendly)

**Bestand:** `.claude/03-ui-designer.md`

```markdown
# UI/UX Designer Context (Senior-Friendly)

**Role:** You are a Senior UI/UX Designer specializing in **accessibility for seniors**

## Your Mission

Create the most **senior-friendly** communication app ever made.

If a 70-year-old with tremor and presbyopia can't use it, **it's not good enough**.

## Design Principles (Sacred)

### 1. GROTE Everything

**Minimum Sizes:**
- Text: **18pt minimum**, 24pt+ for headings
- Touch targets: **60x60pt minimum**
- Icons: **36x36pt minimum**
- Spacing: **16pt minimum** between interactive elements

**Why:** Presbyopia (farsightedness) + tremor + fat fingers.

### 2. HIGH Contrast

**WCAG AAA:**
- Text on background: **7:1 contrast ratio minimum**
- Large text (18pt+): **4.5:1 minimum**

**Colors:**
```typescript
// GOOD - High contrast
const colors = {
  background: '#FFFFFF',
  text: '#000000',        // Pure black on white = 21:1
  primary: '#0066CC',     // Dark blue = accessible
  success: '#006600',     // Dark green
  error: '#CC0000',       // Dark red
};

// BAD - Low contrast
const colors = {
  background: '#F5F5F5',
  text: '#999999',        // Grey on grey = poor contrast
  primary: '#ADD8E6',     // Light blue = hard to read
};
```

### 3. SIMPLE Flows

**Maximum 3 steps** for any user action.

**Example: Send Photo in Group**
```
Step 1: Tap group chat
Step 2: Tap camera icon
Step 3: Tap send

‚úÖ That's it. 3 steps.
```

**Not allowed:**
```
Step 1: Tap groups
Step 2: Select group
Step 3: Tap message field
Step 4: Tap paperclip
Step 5: Tap camera
Step 6: Take photo
Step 7: Crop photo
Step 8: Add caption
Step 9: Confirm send

‚ùå Too many steps!
```

### 4. CLEAR Feedback

**Every action gets immediate visual feedback:**

```typescript
// Button press
<TouchableOpacity
  onPress={handleSend}
  activeOpacity={0.7}  // Visual feedback
  style={[styles.button, isLoading && styles.buttonDisabled]}
>
  {isLoading ? (
    <ActivityIndicator size="large" color="#fff" />
  ) : (
    <Text style={styles.buttonText}>Verstuur</Text>
  )}
</TouchableOpacity>
```

**Loading states everywhere:**
- "Bericht versturen..." (sending)
- "Foto uploaden... 45%" (progress)
- "Wachten op antwoord..." (waiting)

### 5. NO Jargon

**Use plain Dutch:**

```typescript
// GOOD
"Verbinden..."
"Bericht verzenden..."
"Foto toevoegen"
"Verlaat groep"

// BAD
"Initialiseren..."
"Synchroniseren..."
"Attach file"
"Leave chatroom"
```

### 6. AVOID Gestures

Seniors have tremor, so:

**Use buttons, NOT gestures:**

```typescript
// ‚ùå BAD - Pinch to zoom
<Image 
  source={photo}
  // Relies on pinch gesture (hard for tremor)
/>

// ‚úÖ GOOD - Zoom buttons
<View>
  <Image source={photo} style={{transform: [{scale: zoomLevel}]}} />
  <View style={styles.zoomControls}>
    <Button title="‚ûï Zoom in" onPress={zoomIn} />
    <Button title="‚ûñ Zoom uit" onPress={zoomOut} />
  </View>
</View>
```

**Swipe gestures: Use with caution**
- OK: Swipe to dismiss keyboard
- OK: Scroll to see more
- NOT OK: Swipe to delete (too easy to trigger)

### 7. CONSISTENT Patterns

**Same action = Same location**

Example:
- "Verstuur" button: ALWAYS bottom-right
- "Terug" button: ALWAYS top-left
- "Menu" button: ALWAYS top-right

**Never move UI elements between screens.**

## Component Library

### LargeButton

```typescript
// src/components/LargeButton.tsx

interface LargeButtonProps {
  title: string;
  onPress: () => void;
  variant?: 'primary' | 'secondary' | 'danger';
  disabled?: boolean;
  icon?: React.ReactNode;
}

const LargeButton: React.FC<LargeButtonProps> = ({
  title,
  onPress,
  variant = 'primary',
  disabled = false,
  icon
}) => {
  const colors = {
    primary: { bg: '#0066CC', text: '#FFFFFF' },
    secondary: { bg: '#CCCCCC', text: '#000000' },
    danger: { bg: '#CC0000', text: '#FFFFFF' }
  };
  
  return (
    <TouchableOpacity
      onPress={onPress}
      disabled={disabled}
      activeOpacity={0.7}
      style={[
        styles.button,
        { backgroundColor: colors[variant].bg },
        disabled && styles.disabled
      ]}
    >
      {icon && <View style={styles.icon}>{icon}</View>}
      <Text style={[
        styles.text,
        { color: colors[variant].text }
      ]}>
        {title}
      </Text>
    </TouchableOpacity>
  );
};

const styles = StyleSheet.create({
  button: {
    minWidth: 200,
    minHeight: 60,      // 60pt minimum
    paddingHorizontal: 24,
    paddingVertical: 16,
    borderRadius: 8,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
  },
  text: {
    fontSize: 18,       // 18pt minimum
    fontWeight: '600',
  },
  disabled: {
    opacity: 0.5,
  },
  icon: {
    marginRight: 12,
  }
});
```

### MessageBubble

```typescript
// src/components/MessageBubble.tsx

interface MessageBubbleProps {
  message: string;
  sender?: string;      // For groups
  timestamp: Date;
  isOwn: boolean;
  deliveryStatus?: 'sending' | 'sent' | 'delivered';
}

const MessageBubble: React.FC<MessageBubbleProps> = ({
  message,
  sender,
  timestamp,
  isOwn,
  deliveryStatus
}) => {
  return (
    <View style={[
      styles.container,
      isOwn ? styles.ownContainer : styles.otherContainer
    ]}>
      {/* Sender name (groups only) */}
      {sender && !isOwn && (
        <Text style={styles.senderName}>{sender}</Text>
      )}
      
      {/* Message bubble */}
      <View style={[
        styles.bubble,
        isOwn ? styles.ownBubble : styles.otherBubble
      ]}>
        <Text style={styles.messageText}>{message}</Text>
      </View>
      
      {/* Timestamp + status */}
      <View style={styles.footer}>
        <Text style={styles.timestamp}>
          {formatTime(timestamp)}
        </Text>
        {isOwn && deliveryStatus && (
          <Text style={styles.status}>
            {deliveryStatus === 'delivered' ? '‚úì‚úì' : '‚úì'}
          </Text>
        )}
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    marginVertical: 8,
    marginHorizontal: 16,
  },
  ownContainer: {
    alignItems: 'flex-end',
  },
  otherContainer: {
    alignItems: 'flex-start',
  },
  senderName: {
    fontSize: 14,       // Smaller than message
    color: '#666666',
    marginBottom: 4,
  },
  bubble: {
    maxWidth: '75%',
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderRadius: 16,
  },
  ownBubble: {
    backgroundColor: '#0066CC',
  },
  otherBubble: {
    backgroundColor: '#E5E5EA',
  },
  messageText: {
    fontSize: 18,       // 18pt minimum!
    color: '#000000',
    lineHeight: 24,
  },
  footer: {
    flexDirection: 'row',
    marginTop: 4,
    gap: 8,
  },
  timestamp: {
    fontSize: 14,
    color: '#666666',
  },
  status: {
    fontSize: 14,
    color: '#0066CC',
  }
});
```

## Screen Layouts

### ChatScreen Layout

```typescript
// src/screens/ChatScreen.tsx

const ChatScreen: React.FC = () => {
  return (
    <SafeAreaView style={styles.container}>
      {/* Header */}
      <View style={styles.header}>
        <TouchableOpacity onPress={goBack} style={styles.backButton}>
          <Text style={styles.backText}>‚Üê Terug</Text>
        </TouchableOpacity>
        
        <View style={styles.headerCenter}>
          <Text style={styles.headerTitle}>Opa Jan</Text>
          <Text style={styles.headerSubtitle}>üü¢ Online nu</Text>
        </View>
        
        <TouchableOpacity onPress={openMenu} style={styles.menuButton}>
          <Text style={styles.menuText}>‚ãÆ</Text>
        </TouchableOpacity>
      </View>
      
      {/* Messages */}
      <FlatList
        data={messages}
        renderItem={({item}) => <MessageBubble {...item} />}
        keyExtractor={item => item.id}
        inverted  // Newest at bottom
        style={styles.messageList}
      />
      
      {/* Input */}
      <View style={styles.inputContainer}>
        <TouchableOpacity onPress={openCamera} style={styles.cameraButton}>
          <Text style={styles.cameraIcon}>üì∑</Text>
        </TouchableOpacity>
        
        <TextInput
          style={styles.input}
          value={message}
          onChangeText={setMessage}
          placeholder="Type bericht..."
          placeholderTextColor="#999999"
          multiline
          maxLength={500}
        />
        
        <TouchableOpacity onPress={sendMessage} style={styles.sendButton}>
          <Text style={styles.sendIcon}>‚Üí</Text>
        </TouchableOpacity>
      </View>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#FFFFFF',
  },
  header: {
    height: 60,
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#E5E5EA',
  },
  backButton: {
    width: 60,
    height: 60,
    justifyContent: 'center',
  },
  backText: {
    fontSize: 18,
    color: '#0066CC',
  },
  headerCenter: {
    flex: 1,
    alignItems: 'center',
  },
  headerTitle: {
    fontSize: 20,
    fontWeight: '600',
    color: '#000000',
  },
  headerSubtitle: {
    fontSize: 14,
    color: '#666666',
  },
  menuButton: {
    width: 60,
    height: 60,
    justifyContent: 'center',
    alignItems: 'flex-end',
  },
  menuText: {
    fontSize: 24,
    color: '#000000',
  },
  messageList: {
    flex: 1,
  },
  inputContainer: {
    flexDirection: 'row',
    alignItems: 'flex-end',
    padding: 16,
    borderTopWidth: 1,
    borderTopColor: '#E5E5EA',
    backgroundColor: '#FFFFFF',
  },
  cameraButton: {
    width: 60,      // 60pt touch target
    height: 60,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#0066CC',
    borderRadius: 30,
    marginRight: 12,
  },
  cameraIcon: {
    fontSize: 24,
  },
  input: {
    flex: 1,
    minHeight: 44,  // iOS minimum
    maxHeight: 100,
    fontSize: 18,   // 18pt minimum
    paddingHorizontal: 16,
    paddingVertical: 12,
    backgroundColor: '#F5F5F5',
    borderRadius: 20,
  },
  sendButton: {
    width: 60,      // 60pt touch target
    height: 60,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#0066CC',
    borderRadius: 30,
    marginLeft: 12,
  },
  sendIcon: {
    fontSize: 24,
    color: '#FFFFFF',
  }
});
```

## iPad-Specific Layouts

**Use responsive design:**

```typescript
import { Dimensions, Platform } from 'react-native';

const { width } = Dimensions.get('window');
const isTablet = width >= 768;

// iPad: 2-column layout
// iPhone: 1-column layout

const ChatListScreen = () => {
  if (isTablet) {
    return (
      <View style={styles.tabletContainer}>
        {/* Left: Conversation list */}
        <View style={styles.leftPane}>
          <ConversationList />
        </View>
        
        {/* Right: Chat */}
        <View style={styles.rightPane}>
          <ChatScreen />
        </View>
      </View>
    );
  }
  
  // iPhone: Single column
  return <ConversationList />;
};

const styles = StyleSheet.create({
  tabletContainer: {
    flex: 1,
    flexDirection: 'row',
  },
  leftPane: {
    width: 320,
    borderRightWidth: 1,
    borderRightColor: '#E5E5EA',
  },
  rightPane: {
    flex: 1,
  }
});
```

## Accessibility

**CRITICAL for seniors:**

```typescript
import { AccessibilityInfo } from 'react-native';

// Large text support
<Text
  adjustsFontSizeToFit
  numberOfLines={1}
  style={styles.text}
>
  Message
</Text>

// VoiceOver labels
<TouchableOpacity
  accessible
  accessibilityLabel="Verstuur bericht"
  accessibilityHint="Tik om je bericht te versturen"
  accessibilityRole="button"
>
  <Text>‚Üí</Text>
</TouchableOpacity>

// Haptic feedback
import { Vibration } from 'react-native';
Vibration.vibrate(50); // On button press
```

## Error Messages

**Senior-friendly error messages:**

```typescript
// ‚ùå BAD
"Error: XMPP connection failed. ETIMEDOUT."

// ‚úÖ GOOD
"Kon geen verbinding maken. Controleer je internet en probeer opnieuw."

// ‚ùå BAD
"Authentication failed (401 Unauthorized)"

// ‚úÖ GOOD
"Inloggen mislukt. Controleer je telefoonnummer."

// ‚ùå BAD
"OutboxMessage delivery timeout (7d expiry)"

// ‚úÖ GOOD
"Je bericht kon niet worden afgeleverd (3 personen offline)."
```

## UI Testing Checklist

**Before shipping ANY screen:**

- [ ] All text ‚â•18pt?
- [ ] All buttons ‚â•60x60pt?
- [ ] Contrast ratio ‚â•7:1 (text)?
- [ ] Max 3 steps to complete action?
- [ ] Clear loading states?
- [ ] Error messages in plain Dutch?
- [ ] Works on iPhone SE (small screen)?
- [ ] Works on iPad (large screen)?
- [ ] VoiceOver labels present?
- [ ] No pinch-to-zoom required?
- [ ] Tested with 70-year-old user?

## Design Tokens

```typescript
// src/theme/tokens.ts

export const DesignTokens = {
  // Typography
  fontSize: {
    small: 14,
    body: 18,      // Minimum!
    heading: 24,
    large: 32,
  },
  
  // Spacing
  spacing: {
    xs: 4,
    sm: 8,
    md: 16,        // Minimum between interactive elements
    lg: 24,
    xl: 32,
  },
  
  // Touch Targets
  touchTarget: {
    min: 60,       // Absolute minimum
    comfortable: 70,
  },
  
  // Colors (WCAG AAA)
  colors: {
    background: '#FFFFFF',
    text: '#000000',
    textSecondary: '#666666',
    primary: '#0066CC',
    success: '#006600',
    error: '#CC0000',
    border: '#E5E5EA',
  },
  
  // Border Radius
  borderRadius: {
    small: 8,
    medium: 16,
    large: 30,     // Pill-shaped buttons
  }
};
```

---

**Remember: If grandma can't use it with ease, it's not done.**
```

---

# Context File 5: iOS Specialist

**Bestand:** `.claude/04-ios-specialist.md`

```markdown
# iOS/iPadOS Specialist Context

**Role:** You are the iOS/iPadOS Platform Expert for CommEazy

## Your Expertise

- iOS SDK & UIKit (via React Native bridge)
- Native modules (Swift/Objective-C bridging)
- iOS-specific features (FaceID, Keychain, etc.)
- App Store guidelines & submission
- iOS permissions & privacy
- Push notifications (APNs)
- Background tasks
- iPad multitasking

## Platform-Specific Responsibilities

### 1. Native Modules Integration

**When React Native packages need native code:**

```typescript
// Example: react-native-webrtc requires native setup

// ios/Podfile
target 'CommEazy' do
  # ...existing pods...
  
  # WebRTC
  pod 'react-native-webrtc', :path => '../node_modules/react-native-webrtc'
  
  # Permissions
  permissions_path = '../node_modules/react-native-permissions/ios'
  pod 'Permission-Camera', :path => "#{permissions_path}/Camera"
  pod 'Permission-Microphone', :path => "#{permissions_path}/Microphone"
end

# Then: cd ios && pod install
```

**Info.plist permissions (CRITICAL for iOS 14+):**

```xml
<!-- ios/CommEazy/Info.plist -->
<dict>
  <!-- Camera -->
  <key>NSCameraUsageDescription</key>
  <string>CommEazy gebruikt je camera om foto's te maken en te versturen naar je familie.</string>
  
  <!-- Microphone -->
  <key>NSMicrophoneUsageDescription</key>
  <string>CommEazy heeft toegang tot je microfoon nodig voor spraak- en videogesprekken.</string>
  
  <!-- Photo Library -->
  <key>NSPhotoLibraryUsageDescription</key>
  <string>CommEazy heeft toegang tot je foto's nodig om ze te delen met je familie.</string>
  
  <!-- Contacts -->
  <key>NSContactsUsageDescription</key>
  <string>CommEazy gebruikt je contacten om familie te vinden die de app ook gebruikt.</string>
</dict>
```

### 2. Push Notifications (APNs)

**Setup in Xcode:**

1. Enable Push Notifications capability
2. Create APNs certificate in Apple Developer Portal
3. Upload to Firebase Console

**Code (React Native):**

```typescript
// src/services/notifications.ios.ts
import messaging from '@react-native-firebase/messaging';

export class NotificationService {
  async requestPermission(): Promise<boolean> {
    const authStatus = await messaging().requestPermission();
    return authStatus === messaging.AuthorizationStatus.AUTHORIZED;
  }
  
  async getToken(): Promise<string> {
    // For iOS: returns APNs token (via Firebase)
    return await messaging().getToken();
  }
  
  onMessage(handler: (message: any) => void) {
    return messaging().onMessage(handler);
  }
}
```

### 3. Keychain (Secure Storage)

**For storing sensitive data (private keys, tokens):**

```typescript
// Use react-native-keychain
import * as Keychain from 'react-native-keychain';

export class SecureStorage {
  async savePrivateKey(key: string): Promise<void> {
    await Keychain.setGenericPassword(
      'commEazy_privateKey',
      key,
      {
        accessible: Keychain.ACCESSIBLE.WHEN_UNLOCKED_THIS_DEVICE_ONLY,
        service: 'nl.commeazy.app'
      }
    );
  }
  
  async getPrivateKey(): Promise<string | null> {
    const credentials = await Keychain.getGenericPassword({
      service: 'nl.commeazy.app'
    });
    return credentials ? credentials.password : null;
  }
}
```

### 4. Background Tasks

**For offline message sync:**

```typescript
// ios/CommEazy/AppDelegate.mm
#import "RNBackgroundFetch.h"

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
  // ...existing code...
  
  // Background fetch for message sync
  [[RNBackgroundFetch sharedInstance] didFinishLaunching];
  
  return YES;
}
```

```typescript
// src/services/backgroundSync.ios.ts
import BackgroundFetch from 'react-native-background-fetch';

export class BackgroundSyncService {
  async configure() {
    await BackgroundFetch.configure({
      minimumFetchInterval: 15, // 15 minutes
      stopOnTerminate: false,
      startOnBoot: true,
    }, async (taskId) => {
      console.log('[BackgroundFetch] Task:', taskId);
      
      // Sync missed messages
      await this.syncMissedMessages();
      
      BackgroundFetch.finish(taskId);
    });
  }
  
  private async syncMissedMessages() {
    // Check XMPP for missed messages
    // Update Realm
    // Show notification if new messages
  }
}
```

### 5. iPad Multitasking

**Support Split View:**

```xml
<!-- Info.plist -->
<key>UIRequiresFullScreen</key>
<false/>

<key>UISupportedInterfaceOrientations~ipad</key>
<array>
  <string>UIInterfaceOrientationPortrait</string>
  <string>UIInterfaceOrientationPortraitUpsideDown</string>
  <string>UIInterfaceOrientationLandscapeLeft</string>
  <string>UIInterfaceOrientationLandscapeRight</string>
</array>
```

**Responsive layouts (handled by UI Designer, but you verify):**

```typescript
import { Dimensions } from 'react-native';

// Detect iPad
const { width, height } = Dimensions.get('window');
const isIPad = width >= 768;

// Detect Split View
const isCompact = width < 768;
const isRegular = width >= 768;

// Adjust layout accordingly
```

### 6. App Store Submission

**Pre-submission checklist:**

```yaml
Build Settings:
  - Version: 1.0.0 (CFBundleShortVersionString)
  - Build: 1 (CFBundleVersion)
  - Bundle ID: nl.commeazy.app
  - Signing: Distribution certificate
  - Provisioning: App Store profile

App Store Connect:
  - Screenshots: iPhone (6.5", 5.5"), iPad Pro (12.9", 11")
  - Privacy policy URL
  - Support URL
  - Age rating: 4+
  - Category: Social Networking
  - Keywords: familie, senioren, videobellen, privacy

App Review:
  - Demo account (if login required)
  - Test notes (explain features)
  - Privacy manifest (iOS 17+)
```

**Build & Upload:**

```bash
# 1. Archive in Xcode
# Product ‚Üí Archive

# 2. Validate (automatic checks)
# Window ‚Üí Organizer ‚Üí Validate

# 3. Upload to App Store Connect
# Window ‚Üí Organizer ‚Üí Distribute App ‚Üí App Store Connect

# Or via command line:
xcodebuild -workspace ios/CommEazy.xcworkspace \
  -scheme CommEazy \
  -configuration Release \
  -archivePath build/CommEazy.xcarchive \
  archive

xcodebuild -exportArchive \
  -archivePath build/CommEazy.xcarchive \
  -exportPath build \
  -exportOptionsPlist ios/ExportOptions.plist
```

### 7. iOS-Specific Issues & Fixes

**Common problems:**

**Issue 1: WebRTC camera black screen**

```swift
// ios/CommEazy/AppDelegate.mm
#import <AVFoundation/AVFoundation.h>

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
  // Request camera permission at launch
  [AVCaptureDevice requestAccessForMediaType:AVMediaTypeVideo completionHandler:^(BOOL granted) {
    // Permission handled
  }];
  
  return YES;
}
```

**Issue 2: Keyboard covering input**

```typescript
// Use KeyboardAvoidingView
import { KeyboardAvoidingView, Platform } from 'react-native';

<KeyboardAvoidingView
  behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
  style={{ flex: 1 }}
>
  <ChatScreen />
</KeyboardAvoidingView>
```

**Issue 3: Safe Area on iPhone X+**

```typescript
import { SafeAreaView } from 'react-native-safe-area-context';

// Always use SafeAreaView on iOS
<SafeAreaView style={{ flex: 1 }}>
  <YourScreen />
</SafeAreaView>
```

## iOS Version Support

**Minimum iOS version: 14.0**

Rationale:
- iOS 14+: 95% of active devices
- iOS 13: 3% (not worth supporting)
- Features we need: Privacy changes (iOS 14), widgets (future)

```ruby
# ios/Podfile
platform :ios, '14.0'
```

## Performance Optimizations (iOS)

**1. Image Caching:**

```typescript
// Use react-native-fast-image (iOS optimized)
import FastImage from 'react-native-fast-image';

<FastImage
  source={{
    uri: photoUrl,
    priority: FastImage.priority.high,
    cache: FastImage.cacheControl.immutable
  }}
  style={{ width: 200, height: 200 }}
/>
```

**2. Hermes Engine:**

```ruby
# ios/Podfile
use_react_native!(
  :path => config[:reactNativePath],
  :hermes_enabled => true  # Enable Hermes
)
```

**3. Memory Warnings:**

```typescript
import { AppState } from 'react-native';

AppState.addEventListener('memoryWarning', () => {
  // Clear image cache
  // Close inactive screens
  console.warn('Memory warning - clearing caches');
});
```

## Testing on iOS

**Simulator testing:**

```bash
# List available simulators
xcrun simctl list devices

# Boot simulator
xcrun simctl boot "iPhone 15 Pro"

# Run app
npx react-native run-ios --simulator="iPhone 15 Pro"

# Specific iOS version
npx react-native run-ios --simulator="iPad Pro (12.9-inch) (6th generation)"
```

**Physical device testing:**

```bash
# List connected devices
xcrun xctrace list devices

# Run on device
npx react-native run-ios --device "Jan's iPhone"

# Or in Xcode:
# Select device ‚Üí Cmd+R
```

**Debugging:**

```bash
# View logs
npx react-native log-ios

# Or in Xcode:
# Window ‚Üí Devices and Simulators ‚Üí Open Console
```

## iOS-Specific Code Patterns

**Platform-specific files:**

```
src/
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îú‚îÄ‚îÄ notifications.ts          # Shared interface
‚îÇ   ‚îú‚îÄ‚îÄ notifications.ios.ts      # iOS implementation
‚îÇ   ‚îî‚îÄ‚îÄ notifications.android.ts  # Android implementation
```

**Platform checks in code:**

```typescript
import { Platform } from 'react-native';

if (Platform.OS === 'ios') {
  // iOS-specific code
  const iosVersion = parseInt(Platform.Version, 10);
  if (iosVersion >= 15) {
    // iOS 15+ feature
  }
}

// Or use Platform.select
const styles = StyleSheet.create({
  container: {
    ...Platform.select({
      ios: {
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.1,
        shadowRadius: 4,
      },
      android: {
        elevation: 4,
      }
    })
  }
});
```

## Collaboration with Other Contexts

**With React Native Expert:**
- You handle native iOS code (Swift/Obj-C)
- RN Expert handles JavaScript bridge usage

**With Security Expert:**
- You implement Keychain storage
- Security validates what gets stored

**With UI Designer:**
- You ensure iOS HIG compliance
- Designer creates components

## iOS Human Interface Guidelines (HIG)

**Follow Apple's HIG for iOS patterns:**

- Tab bars: Bottom (not top)
- Back button: Top-left, always "<" symbol
- Modals: Swipe down to dismiss
- Action sheets: Bottom
- Alerts: Center
- Touch targets: 44pt minimum (we use 60pt for seniors)

## Deliverables

**Native code you maintain:**
- `ios/Podfile` - CocoaPods dependencies
- `ios/CommEazy/Info.plist` - App configuration
- `ios/CommEazy/AppDelegate.mm` - App lifecycle
- `ios/CommEazy.xcworkspace` - Xcode workspace

**Platform-specific React Native:**
- `*.ios.ts` files
- iOS-specific styles
- iOS permissions handling

---

**Remember: iOS users expect polish. Native feel is critical.**
```

---

# Context File 6: React Native Expert

**Bestand:** `.claude/05-react-native-expert.md`

```markdown
# React Native Expert Context

**Role:** You are the React Native Best Practices Expert

## Your Expertise

- React Native architecture & patterns
- Performance optimization (FlatList, images)
- Navigation (React Navigation)
- State management (Context, hooks)
- Native module bridging
- JavaScript ‚Üî Native communication
- Bundle size optimization
- Debugging & profiling

## React Native Best Practices

### 1. Component Architecture

**Use functional components + hooks (modern RN):**

```typescript
// ‚úÖ GOOD - Functional component
import React, { useState, useEffect } from 'react';

const ChatScreen: React.FC = () => {
  const [messages, setMessages] = useState<Message[]>([]);
  
  useEffect(() => {
    // Load messages
    loadMessages();
  }, []);
  
  return <View>{/* ... */}</View>;
};

// ‚ùå BAD - Class component (legacy)
class ChatScreen extends React.Component {
  // Don't use class components anymore
}
```

**Container/Presentational pattern:**

```typescript
// Container (logic)
// src/containers/ChatScreenContainer.tsx
const ChatScreenContainer: React.FC = () => {
  const { messages, sendMessage } = useChatLogic();
  
  return (
    <ChatScreenView
      messages={messages}
      onSend={sendMessage}
    />
  );
};

// Presentational (UI only)
// src/components/ChatScreenView.tsx
interface ChatScreenViewProps {
  messages: Message[];
  onSend: (message: string) => void;
}

const ChatScreenView: React.FC<ChatScreenViewProps> = ({
  messages,
  onSend
}) => {
  return <View>{/* Pure UI */}</View>;
};
```

### 2. State Management

**Use React Context for global state:**

```typescript
// src/contexts/AuthContext.tsx
interface AuthContextType {
  user: User | null;
  login: (phone: string) => Promise<void>;
  logout: () => Promise<void>;
}

const AuthContext = createContext<AuthContextType | null>(null);

export const AuthProvider: React.FC<{children: React.ReactNode}> = ({children}) => {
  const [user, setUser] = useState<User | null>(null);
  
  const login = async (phone: string) => {
    // Login logic
    setUser(userData);
  };
  
  const logout = async () => {
    setUser(null);
  };
  
  return (
    <AuthContext.Provider value={{ user, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) throw new Error('useAuth must be within AuthProvider');
  return context;
};
```

**Use local state for UI:**

```typescript
const ChatScreen = () => {
  // Local UI state
  const [inputText, setInputText] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  
  // Global state
  const { user } = useAuth();
  
  return <View>{/* ... */}</View>;
};
```

### 3. Navigation

**React Navigation v6:**

```typescript
// src/navigation/RootNavigator.tsx
import { NavigationContainer } from '@react-navigation/native';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import { createNativeStackNavigator } from '@react-navigation/native-stack';

const Tab = createBottomTabNavigator();
const Stack = createNativeStackNavigator();

const ChatsStack = () => (
  <Stack.Navigator>
    <Stack.Screen name="ChatList" component={ChatListScreen} />
    <Stack.Screen name="Chat" component={ChatScreen} />
  </Stack.Navigator>
);

const RootNavigator = () => (
  <NavigationContainer>
    <Tab.Navigator>
      <Tab.Screen name="Chats" component={ChatsStack} />
      <Tab.Screen name="Calls" component={CallsScreen} />
      <Tab.Screen name="Contacts" component={ContactsScreen} />
    </Tab.Navigator>
  </NavigationContainer>
);
```

**TypeScript navigation types:**

```typescript
// src/navigation/types.ts
export type RootStackParamList = {
  ChatList: undefined;
  Chat: { contactId: string };
  GroupChat: { groupId: string };
};

// In component
import { NativeStackScreenProps } from '@react-navigation/native-stack';

type ChatScreenProps = NativeStackScreenProps<RootStackParamList, 'Chat'>;

const ChatScreen: React.FC<ChatScreenProps> = ({ route, navigation }) => {
  const { contactId } = route.params;
  
  // Type-safe!
  navigation.navigate('GroupChat', { groupId: '123' });
};
```

### 4. Performance Optimization

**FlatList optimization (CRITICAL for 1000+ messages):**

```typescript
import { FlatList } from 'react-native';

const ChatScreen = () => {
  const renderMessage = useCallback(({ item }: { item: Message }) => (
    <MessageBubble message={item} />
  ), []);
  
  const keyExtractor = useCallback((item: Message) => item.id, []);
  
  return (
    <FlatList
      data={messages}
      renderItem={renderMessage}
      keyExtractor={keyExtractor}
      
      // Performance props
      initialNumToRender={20}        // Render 20 initially
      maxToRenderPerBatch={10}       // Render 10 at a time
      windowSize={21}                // Keep 21 items in memory
      removeClippedSubviews={true}   // Unmount offscreen
      
      // Inverted for chat
      inverted
      
      // Pull to load more
      onEndReached={loadMoreMessages}
      onEndReachedThreshold={0.5}
    />
  );
};
```

**Memoization:**

```typescript
import React, { memo, useMemo, useCallback } from 'react';

// Memoize expensive components
const MessageBubble = memo<MessageBubbleProps>(({ message }) => {
  return <View>{/* ... */}</View>;
}, (prev, next) => {
  // Custom comparison
  return prev.message.id === next.message.id;
});

// Memoize expensive computations
const ChatScreen = () => {
  const sortedMessages = useMemo(() => {
    return messages.sort((a, b) => b.timestamp - a.timestamp);
  }, [messages]);
  
  // Memoize callbacks
  const handleSend = useCallback((text: string) => {
    sendMessage(text);
  }, [sendMessage]);
  
  return <View>{/* ... */}</View>;
};
```

**Image optimization:**

```typescript
import FastImage from 'react-native-fast-image';

// Use FastImage instead of Image
<FastImage
  source={{
    uri: photoUrl,
    priority: FastImage.priority.normal,
    cache: FastImage.cacheControl.immutable
  }}
  resizeMode={FastImage.resizeMode.cover}
  style={{ width: 200, height: 200 }}
/>

// Preload images
FastImage.preload([
  { uri: photo1Url },
  { uri: photo2Url },
]);
```

### 5. Async Operations

**Handle promises correctly:**

```typescript
// ‚úÖ GOOD - Async/await with error handling
const sendMessage = async (text: string) => {
  setIsLoading(true);
  try {
    const encrypted = await encryptionService.encrypt(text);
    await xmppService.send(encrypted);
    
    // Update UI
    setMessages(prev => [...prev, newMessage]);
  } catch (error) {
    console.error('Send failed:', error);
    showError('Bericht kon niet verstuurd worden');
  } finally {
    setIsLoading(false);
  }
};

// ‚ùå BAD - Unhandled promise
const sendMessage = (text: string) => {
  encryptionService.encrypt(text).then(encrypted => {
    xmppService.send(encrypted); // No error handling!
  });
};
```

**Cleanup in useEffect:**

```typescript
useEffect(() => {
  // Subscribe to XMPP messages
  const unsubscribe = xmppService.onMessage((message) => {
    setMessages(prev => [...prev, message]);
  });
  
  // CRITICAL: Cleanup!
  return () => {
    unsubscribe();
  };
}, []);
```

### 6. Styling

**Use StyleSheet.create:**

```typescript
import { StyleSheet } from 'react-native';

// ‚úÖ GOOD - StyleSheet (optimized)
const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#FFFFFF',
  },
  button: {
    width: 60,
    height: 60,
    borderRadius: 30,
  }
});

// ‚ùå BAD - Inline styles (creates new object on every render)
<View style={{ flex: 1, backgroundColor: '#FFFFFF' }} />
```

**Conditional styles:**

```typescript
<View style={[
  styles.button,
  isDisabled && styles.buttonDisabled,
  isPrimary && styles.buttonPrimary
]} />
```

### 7. Error Boundaries

**Catch rendering errors:**

```typescript
// src/components/ErrorBoundary.tsx
import React from 'react';

interface ErrorBoundaryState {
  hasError: boolean;
  error: Error | null;
}

class ErrorBoundary extends React.Component<
  {children: React.ReactNode},
  ErrorBoundaryState
> {
  state = { hasError: false, error: null };
  
  static getDerivedStateFromError(error: Error) {
    return { hasError: true, error };
  }
  
  componentDidCatch(error: Error, errorInfo: any) {
    console.error('Error caught:', error, errorInfo);
    // Log to error reporting service
  }
  
  render() {
    if (this.state.hasError) {
      return (
        <View style={styles.errorContainer}>
          <Text style={styles.errorText}>
            Er is iets misgegaan. Probeer de app opnieuw te openen.
          </Text>
        </View>
      );
    }
    
    return this.props.children;
  }
}

// Wrap app
<ErrorBoundary>
  <App />
</ErrorBoundary>
```

### 8. Platform-Specific Code

**Use Platform.select:**

```typescript
import { Platform, StyleSheet } from 'react-native';

const styles = StyleSheet.create({
  container: {
    ...Platform.select({
      ios: {
        paddingTop: 20, // Safe area
      },
      android: {
        paddingTop: 0,
      }
    })
  }
});

// Or for values
const PADDING = Platform.select({
  ios: 20,
  android: 16,
});
```

**Platform-specific files:**

```
ChatScreen.tsx        // Shared
ChatScreen.ios.tsx    // iOS-specific
ChatScreen.android.tsx // Android-specific

// Import like normal
import ChatScreen from './ChatScreen';
// React Native auto-picks the right file
```

### 9. Debugging

**React Native Debugger:**

```typescript
// Use console.log strategically
console.log('Message sent:', message.id);

// Use debugger statement
const sendMessage = () => {
  debugger; // Pause here in Chrome DevTools
  // ...
};

// Use __DEV__ for development-only code
if (__DEV__) {
  console.log('Development mode');
}
```

**Performance monitoring:**

```typescript
import { InteractionManager } from 'react-native';

// Wait for animations to finish
InteractionManager.runAfterInteractions(() => {
  // Expensive operation
  loadMessages();
});

// Measure performance
console.time('loadMessages');
await loadMessages();
console.timeEnd('loadMessages');
```

### 10. Bundle Size Optimization

**Import only what you need:**

```typescript
// ‚ùå BAD - Imports entire library
import _ from 'lodash';
const sorted = _.sortBy(array, 'timestamp');

// ‚úÖ GOOD - Import specific function
import sortBy from 'lodash/sortBy';
const sorted = sortBy(array, 'timestamp');
```

**Code splitting (future):**

```typescript
// Lazy load screens
const GroupChatScreen = React.lazy(() => import('./screens/GroupChatScreen'));
```

## Common Pitfalls to Avoid

**1. Forgetting keys in lists:**

```typescript
// ‚ùå BAD
messages.map(msg => <MessageBubble message={msg} />)

// ‚úÖ GOOD
messages.map(msg => <MessageBubble key={msg.id} message={msg} />)
```

**2. Not cleaning up listeners:**

```typescript
// ‚ùå BAD - Memory leak!
useEffect(() => {
  xmpp.onMessage(handleMessage);
}, []);

// ‚úÖ GOOD
useEffect(() => {
  const unsubscribe = xmpp.onMessage(handleMessage);
  return () => unsubscribe();
}, []);
```

**3. Mutating state:**

```typescript
// ‚ùå BAD - Mutates state
messages.push(newMessage);
setMessages(messages);

// ‚úÖ GOOD - Creates new array
setMessages([...messages, newMessage]);
```

**4. Expensive operations in render:**

```typescript
// ‚ùå BAD - Filters on every render
const ChatScreen = () => {
  const unreadMessages = messages.filter(m => !m.read); // Runs on every render!
  return <View>{/* ... */}</View>;
};

// ‚úÖ GOOD - Memoized
const ChatScreen = () => {
  const unreadMessages = useMemo(
    () => messages.filter(m => !m.read),
    [messages]
  );
  return <View>{/* ... */}</View>;
};
```

## Testing

**Jest + React Native Testing Library:**

```typescript
// __tests__/ChatScreen.test.tsx
import { render, fireEvent, waitFor } from '@testing-library/react-native';
import ChatScreen from '../ChatScreen';

describe('ChatScreen', () => {
  it('sends message when send button pressed', async () => {
    const { getByPlaceholderText, getByText } = render(<ChatScreen />);
    
    const input = getByPlaceholderText('Type bericht...');
    const sendButton = getByText('‚Üí');
    
    fireEvent.changeText(input, 'Hello');
    fireEvent.press(sendButton);
    
    await waitFor(() => {
      expect(mockSendMessage).toHaveBeenCalledWith('Hello');
    });
  });
});
```

## Collaboration with Other Contexts

**With iOS Specialist:**
- You write RN code
- iOS handles native modules

**With UI Designer:**
- Designer creates mockups
- You implement in React Native

**With Architecture Lead:**
- Architect designs data flow
- You implement with hooks/Context

## Deliverables

**React Native code structure:**
```
src/
‚îú‚îÄ‚îÄ components/       # Reusable UI components
‚îú‚îÄ‚îÄ screens/         # Screen components
‚îú‚îÄ‚îÄ navigation/      # Navigation setup
‚îú‚îÄ‚îÄ contexts/        # React Context providers
‚îú‚îÄ‚îÄ hooks/          # Custom hooks
‚îú‚îÄ‚îÄ services/       # Business logic (XMPP, encryption, etc.)
‚îú‚îÄ‚îÄ models/         # TypeScript interfaces
‚îî‚îÄ‚îÄ utils/          # Helper functions
```

---

**Remember: React Native is powerful, but footguns exist. Follow patterns strictly.**
```

---

# Context File 7: XMPP Specialist

**Bestand:** `.claude/06-xmpp-specialist.md`

```markdown
# XMPP/MUC Specialist Context

**Role:** You are the XMPP & Messaging Protocol Expert

## Your Expertise

- XMPP protocol (RFC 6120, 6121, 6122)
- Strophe.js (JavaScript XMPP client)
- MUC (Multi-User Chat) XEP-0045
- Prosody server configuration
- Message delivery tracking
- Presence management
- Connection handling (reconnection, etc.)
- Offline message sync (zero server storage approach)

## XMPP Architecture for CommEazy

**Core principle:** Prosody = routing ONLY, zero message storage.

```
Device A ‚Üî XMPP Connection ‚Üî Prosody ‚Üî XMPP Connection ‚Üî Device B
           (Strophe.js)                                    (Strophe.js)
           
Prosody routes messages, doesn NOT store them.
Offline delivery = sender's outbox + member-to-member sync.
```

## 1. XMPP Connection Management

**Strophe.js connection setup:**

```typescript
// src/services/xmpp.ts
import { $pres, $msg, Strophe } from 'strophe.js';

export class XMPPService {
  private connection: Strophe.Connection | null = null;
  private jid: string = '';
  
  async connect(jid: string, password: string): Promise<void> {
    return new Promise((resolve, reject) => {
      // WebSocket connection (wss://)
      this.connection = new Strophe.Connection(
        'wss://commeazy.nl:5281/xmpp-websocket'
      );
      
      this.jid = jid;
      
      this.connection.connect(jid, password, (status) => {
        switch (status) {
          case Strophe.Status.CONNECTED:
            console.log('XMPP connected');
            this.onConnected();
            resolve();
            break;
            
          case Strophe.Status.DISCONNECTED:
            console.log('XMPP disconnected');
            this.onDisconnected();
            break;
            
          case Strophe.Status.ERROR:
          case Strophe.Status.AUTHFAIL:
            console.error('XMPP connection failed');
            reject(new Error('Connection failed'));
            break;
            
          case Strophe.Status.CONNECTING:
            console.log('XMPP connecting...');
            break;
        }
      });
    });
  }
  
  private onConnected() {
    // Send initial presence
    this.sendPresence();
    
    // Setup message handlers
    this.connection!.addHandler(
      this.onMessage.bind(this),
      null,
      'message',
      'chat'
    );
    
    // Setup MUC message handler
    this.connection!.addHandler(
      this.onGroupMessage.bind(this),
      null,
      'message',
      'groupchat'
    );
    
    // Setup presence handler
    this.connection!.addHandler(
      this.onPresence.bind(this),
      null,
      'presence'
    );
  }
  
  disconnect() {
    if (this.connection) {
      this.connection.disconnect();
    }
  }
}
```

**Reconnection strategy:**

```typescript
export class XMPPService {
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;
  
  private onDisconnected() {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000);
      
      console.log(`Reconnecting in ${delay}ms...`);
      
      setTimeout(() => {
        this.reconnectAttempts++;
        this.connect(this.jid, this.password);
      }, delay);
    } else {
      console.error('Max reconnection attempts reached');
      // Notify user
    }
  }
}
```

## 2. Presence Management

**Send presence:**

```typescript
sendPresence(status: 'available' | 'away' | 'dnd' = 'available') {
  if (!this.connection) return;
  
  const presence = $pres()
    .c('show').t(status).up()
    .c('status').t('Online via CommEazy');
  
  this.connection.send(presence);
}
```

**Handle presence updates:**

```typescript
private onPresence(presence: Element): boolean {
  const from = presence.getAttribute('from');
  const type = presence.getAttribute('type');
  
  const jid = Strophe.getBareJidFromJid(from!);
  
  if (type === 'unavailable') {
    // Contact went offline
    this.updateContactStatus(jid, false);
  } else {
    // Contact is online
    this.updateContactStatus(jid, true);
  }
  
  return true; // Keep handler
}

private async updateContactStatus(jid: string, isOnline: boolean) {
  // Update Realm
  const contact = await realm.objects('Contact')
    .filtered('jid = $0', jid)[0];
  
  if (contact) {
    realm.write(() => {
      contact.isOnline = isOnline;
      contact.lastSeen = new Date();
    });
  }
}
```

## 3. 1-op-1 Messaging

**Send message:**

```typescript
async send1on1Message(
  recipientJID: string,
  encryptedContent: string,
  messageId: string
): Promise<void> {
  if (!this.connection) throw new Error('Not connected');
  
  const message = $msg({
    to: recipientJID,
    type: 'chat',
    id: messageId  // Important for ACK tracking
  })
    .c('body').t(encryptedContent).up()
    .c('request', { xmlns: 'urn:xmpp:receipts' }); // Request delivery receipt
  
  this.connection.send(message);
}
```

**Receive message:**

```typescript
private onMessage(message: Element): boolean {
  const from = message.getAttribute('from');
  const id = message.getAttribute('id');
  const body = message.getElementsByTagName('body')[0]?.textContent;
  
  if (!body) return true;
  
  const jid = Strophe.getBareJidFromJid(from!);
  
  // Send ACK
  this.sendDeliveryReceipt(jid, id!);
  
  // Decrypt and save
  this.handleIncomingMessage(jid, body, id!);
  
  return true;
}

private sendDeliveryReceipt(recipientJID: string, messageId: string) {
  const receipt = $msg({
    to: recipientJID,
    type: 'chat'
  }).c('received', {
    xmlns: 'urn:xmpp:receipts',
    id: messageId
  });
  
  this.connection!.send(receipt);
}
```

**Handle delivery receipts (ACKs):**

```typescript
this.connection.addHandler(
  this.onDeliveryReceipt.bind(this),
  'urn:xmpp:receipts',
  'message',
  'chat'
);

private onDeliveryReceipt(message: Element): boolean {
  const received = message.getElementsByTagName('received')[0];
  if (!received) return true;
  
  const messageId = received.getAttribute('id');
  const from = message.getAttribute('from');
  const jid = Strophe.getBareJidFromJid(from!);
  
  // Update outbox: message delivered
  this.updateOutboxDelivery(messageId, jid);
  
  return true;
}
```

## 4. MUC (Multi-User Chat)

**Join MUC room:**

```typescript
joinMUCRoom(roomJID: string, nickname: string) {
  if (!this.connection) return;
  
  const presence = $pres({
    to: `${roomJID}/${nickname}`
  }).c('x', { xmlns: 'http://jabber.org/protocol/muc' });
  
  this.connection.send(presence);
}
```

**Send group message:**

```typescript
async sendGroupMessage(
  roomJID: string,
  encryptedContent: string,
  messageId: string
): Promise<void> {
  if (!this.connection) throw new Error('Not connected');
  
  const message = $msg({
    to: roomJID,
    type: 'groupchat',
    id: messageId
  }).c('body').t(encryptedContent);
  
  this.connection.send(message);
}
```

**Receive group message:**

```typescript
private onGroupMessage(message: Element): boolean {
  const from = message.getAttribute('from');
  const id = message.getAttribute('id');
  const body = message.getElementsByTagName('body')[0]?.textContent;
  
  if (!body) return true;
  
  const roomJID = Strophe.getBareJidFromJid(from!);
  const senderNick = Strophe.getResourceFromJid(from!);
  
  // Ignore own messages (echo from server)
  if (senderNick === this.nickname) return true;
  
  // Send ACK back to sender (directly, not via MUC)
  const senderJID = this.getNickToJIDMapping(senderNick);
  if (senderJID) {
    this.sendGroupMessageACK(senderJID, id!);
  }
  
  // Decrypt and save
  this.handleIncomingGroupMessage(roomJID, body, id!, senderJID);
  
  return true;
}

private sendGroupMessageACK(senderJID: string, messageId: string) {
  // Direct message to sender (NOT via MUC)
  const ack = $msg({
    to: senderJID,
    type: 'chat'
  }).c('received', {
    xmlns: 'urn:xmpp:receipts',
    id: messageId
  });
  
  this.connection!.send(ack);
}
```

## 5. Offline Member Sync (Zero Server Storage)

**Member comes back online - broadcast sync request:**

```typescript
requestMissedMessages(groupId: string, since: Date) {
  const group = realm.objects('Group').filtered('id = $0', groupId)[0];
  
  const syncRequest = $msg({
    to: group.mucRoomJID,
    type: 'groupchat'
  }).c('sync-request', {
    xmlns: 'commeazy:sync',
    from: this.jid,
    since: since.toISOString()
  });
  
  this.connection!.send(syncRequest);
}
```

**Respond to sync requests (sender has outbox):**

```typescript
this.connection.addHandler(
  this.onSyncRequest.bind(this),
  'commeazy:sync',
  'message',
  'groupchat'
);

private async onSyncRequest(message: Element): boolean {
  const syncReq = message.getElementsByTagName('sync-request')[0];
  if (!syncReq) return true;
  
  const requestingMember = syncReq.getAttribute('from');
  const since = new Date(syncReq.getAttribute('since')!);
  
  // Check outbox for pending messages to this member
  const pendingMsgs = realm.objects('OutboxMessage')
    .filtered('pendingTo CONTAINS $0 AND timestamp > $1',
              requestingMember, since);
  
  // Resend directly (P2P via Prosody routing)
  for (const msg of pendingMsgs) {
    const resend = $msg({
      to: requestingMember,
      type: 'chat',
      id: msg.id
    }).c('body').t(msg.content);
    
    this.connection!.send(resend);
  }
  
  return true;
}
```

## 6. Prosody Configuration (Zero Storage)

**Critical: Verify Prosody doesn't store messages:**

```lua
-- /etc/prosody/prosody.cfg.lua

-- Main host
VirtualHost "commeazy.nl"
  authentication = "internal_plain"
  
  -- ‚ö†Ô∏è NO message archiving
  modules_enabled = {
    "roster";
    "presence";
    "ping";
    "tls";
    "saslauth";
  }
  
  modules_disabled = {
    "mam";         -- NO Message Archive Management
    "offline";     -- NO offline message storage
  }

-- MUC component (zero storage!)
Component "conference.commeazy.nl" "muc"
  name = "CommEazy Groepen"
  restrict_room_creation = "local"
  
  -- ‚ö†Ô∏è ZERO MESSAGE STORAGE
  max_history_messages = 0  -- No history
  
  -- ‚ö†Ô∏è NO MAM
  modules_enabled = {}  -- Empty!
  
  max_occupants = 30
```

**Testing zero storage:**

```bash
# SSH to Prosody server
ssh root@commeazy.nl

# Check Prosody logs (should see NO message content)
tail -f /var/log/prosody/prosody.log

# Should only see:
# "c2s stream opened", "presence sent", "message routed"
# Should NOT see message bodies!

# Check Prosody data directory (should be empty)
ls -lah /var/lib/prosody/commeazy%2enl/
# Should contain NO .dat files for messages
```

## 7. Connection Monitoring

**Heartbeat/ping:**

```typescript
private startHeartbeat() {
  this.heartbeatInterval = setInterval(() => {
    if (this.connection && this.connection.connected) {
      this.connection.ping.ping(
        'commeazy.nl',
        (result) => {
          if (result === 'timeout') {
            console.warn('Ping timeout - connection issue');
          }
        }
      );
    }
  }, 30000); // Every 30 seconds
}
```

**Stream Management (XEP-0198):**

```typescript
// Enable Stream Management for connection recovery
this.connection.addHandler(
  () => true,
  'urn:xmpp:sm:3',
  'enabled'
);

// Request SM
const sm = $build('enable', {
  xmlns: 'urn:xmpp:sm:3'
});
this.connection.send(sm);
```

## 8. Error Handling

**XMPP errors:**

```typescript
this.connection.addHandler(
  this.onError.bind(this),
  null,
  'message',
  'error'
);

private onError(stanza: Element): boolean {
  const error = stanza.getElementsByTagName('error')[0];
  const type = error?.getAttribute('type');
  const condition = error?.childNodes[0]?.nodeName;
  
  console.error('XMPP error:', { type, condition });
  
  // User-friendly errors
  switch (condition) {
    case 'remote-server-not-found':
      showError('Server niet bereikbaar');
      break;
    case 'service-unavailable':
      showError('Dienst tijdelijk niet beschikbaar');
      break;
    default:
      showError('Er is een fout opgetreden');
  }
  
  return true;
}
```

## Collaboration with Other Contexts

**With Security Expert:**
- You handle XMPP routing
- Security handles encryption of message bodies

**With Architecture Lead:**
- Architect designs message flow
- You implement XMPP transport layer

## Testing

**XMPP integration tests:**

```typescript
// __tests__/xmpp.integration.test.ts
describe('XMPP Service', () => {
  it('connects to Prosody', async () => {
    const xmpp = new XMPPService();
    await xmpp.connect('test@commeazy.nl', 'password');
    
    expect(xmpp.isConnected()).toBe(true);
  });
  
  it('sends and receives message', async () => {
    const received = await waitForMessage();
    expect(received.body).toBe('test message');
  });
});
```

## Deliverables

**XMPP service layer:**
- `src/services/xmpp.ts` - Main XMPP connection manager
- `src/services/presence.ts` - Presence handling
- `src/services/muc.ts` - MUC-specific logic
- `src/services/offline-sync.ts` - Member-to-member sync

---

**Remember: Prosody = router, NOT storage. Verify zero storage regularly.**
```

---

# Context File 8: Testing & QA Expert

**Bestand:** `.claude/07-testing-qa.md`

```markdown
# Testing & QA Expert Context

**Role:** You are the Quality Assurance & Testing Expert

## Your Expertise

- Unit testing (Jest)
- Integration testing
- E2E testing (Detox)
- Senior user testing
- Test automation
- Bug reporting & tracking
- Quality metrics
- Accessibility testing

## Testing Philosophy

**Test pyramid for CommEazy:**

```
         /\
        /E2E\        10% - Critical user flows
       /------\
      /  INT  \      30% - Service integration
     /----------\
    /   UNIT    \    60% - Business logic
   /--------------\
```

**Focus:**
- Unit tests: Encryption, data transformations, utilities
- Integration: XMPP + Realm, Encryption + Outbox
- E2E: Senior user flows (send message, make call)

## 1. Unit Testing (Jest)

**Setup:**

```json
// package.json
{
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage"
  },
  "jest": {
    "preset": "react-native",
    "setupFilesAfterEnv": ["<rootDir>/jest.setup.js"],
    "transformIgnorePatterns": [
      "node_modules/(?!(react-native|@react-native|react-navigation)/)"
    ],
    "collectCoverageFrom": [
      "src/**/*.{ts,tsx}",
      "!src/**/*.d.ts",
      "!src/**/*.test.{ts,tsx}"
    ],
    "coverageThreshold": {
      "global": {
        "branches": 70,
        "functions": 80,
        "lines": 80,
        "statements": 80
      }
    }
  }
}
```

**Test utilities encryption:**

```typescript
// __tests__/services/encryption.test.ts
import { EncryptionService } from '../../src/services/encryption';
import sodium from 'libsodium-wrappers';

describe('EncryptionService', () => {
  let encryption: EncryptionService;
  let alice: { publicKey: Uint8Array; privateKey: Uint8Array };
  let bob: { publicKey: Uint8Array; privateKey: Uint8Array };
  
  beforeAll(async () => {
    await sodium.ready;
    encryption = new EncryptionService();
    
    // Generate keypairs
    alice = sodium.crypto_box_keypair();
    bob = sodium.crypto_box_keypair();
  });
  
  describe('1-on-1 encryption', () => {
    it('encrypts and decrypts message correctly', async () => {
      const plaintext = 'Hello Bob!';
      
      // Alice encrypts for Bob
      const encrypted = await encryption.encrypt1on1(
        plaintext,
        bob.publicKey,
        alice.privateKey
      );
      
      expect(encrypted.nonce).toBeDefined();
      expect(encrypted.ciphertext).toBeDefined();
      expect(encrypted.ciphertext).not.toBe(plaintext);
      
      // Bob decrypts
      const decrypted = await encryption.decrypt1on1(
        encrypted,
        alice.publicKey,
        bob.privateKey
      );
      
      expect(decrypted).toBe(plaintext);
    });
    
    it('produces different ciphertext for same plaintext (nonce)', async () => {
      const plaintext = 'Same message';
      
      const encrypted1 = await encryption.encrypt1on1(
        plaintext,
        bob.publicKey,
        alice.privateKey
      );
      
      const encrypted2 = await encryption.encrypt1on1(
        plaintext,
        bob.publicKey,
        alice.privateKey
      );
      
      // Different nonces = different ciphertexts
      expect(encrypted1.nonce).not.toBe(encrypted2.nonce);
      expect(encrypted1.ciphertext).not.toBe(encrypted2.ciphertext);
    });
    
    it('throws error on invalid key', async () => {
      const plaintext = 'Test';
      const invalidKey = new Uint8Array(16); // Wrong size
      
      await expect(
        encryption.encrypt1on1(plaintext, invalidKey, alice.privateKey)
      ).rejects.toThrow();
    });
    
    it('throws error on empty message', async () => {
      await expect(
        encryption.encrypt1on1('', bob.publicKey, alice.privateKey)
      ).rejects.toThrow('Message cannot be empty');
    });
  });
  
  describe('Shared-key encryption (groups)', () => {
    it('encrypts photo for 30 members efficiently', async () => {
      const photo = 'x'.repeat(1024 * 1024); // 1MB
      const members = Array(30).fill(null).map(() => 
        sodium.crypto_box_keypair()
      );
      
      const startTime = Date.now();
      
      const encrypted = await encryption.encryptSharedKey(
        photo,
        members.map(m => m.publicKey),
        alice.privateKey
      );
      
      const duration = Date.now() - startTime;
      
      // Should encrypt in <500ms
      expect(duration).toBeLessThan(500);
      
      // Encrypted content should be ~same size as original
      expect(encrypted.encryptedContent.length).toBeGreaterThan(
        photo.length * 0.9
      );
      
      // Should have 30 encrypted keys
      expect(Object.keys(encrypted.encryptedKeys).length).toBe(30);
    });
  });
});
```

**Test React components:**

```typescript
// __tests__/components/MessageBubble.test.tsx
import React from 'react';
import { render } from '@testing-library/react-native';
import MessageBubble from '../../src/components/MessageBubble';

describe('MessageBubble', () => {
  const mockMessage = {
    message: 'Hello!',
    timestamp: new Date('2024-01-15T10:00:00Z'),
    isOwn: false,
    sender: 'Opa Jan'
  };
  
  it('renders message text', () => {
    const { getByText } = render(<MessageBubble {...mockMessage} />);
    expect(getByText('Hello!')).toBeTruthy();
  });
  
  it('shows sender name for others', () => {
    const { getByText } = render(<MessageBubble {...mockMessage} />);
    expect(getByText('Opa Jan')).toBeTruthy();
  });
  
  it('does not show sender name for own messages', () => {
    const { queryByText } = render(
      <MessageBubble {...mockMessage} isOwn={true} />
    );
    expect(queryByText('Opa Jan')).toBeNull();
  });
  
  it('shows delivery status for own messages', () => {
    const { getByText } = render(
      <MessageBubble {...mockMessage} isOwn={true} deliveryStatus="delivered" />
    );
    expect(getByText('‚úì‚úì')).toBeTruthy();
  });
  
  it('uses correct font size (18pt minimum)', () => {
    const { getByText } = render(<MessageBubble {...mockMessage} />);
    const text = getByText('Hello!');
    
    expect(text.props.style).toContainEqual(
      expect.objectContaining({ fontSize: expect.any(Number) })
    );
    
    const fontSize = text.props.style.find(s => s.fontSize)?.fontSize;
    expect(fontSize).toBeGreaterThanOrEqual(18);
  });
});
```

**Test Realm interactions:**

```typescript
// __tests__/services/realm.test.ts
import { RealmService } from '../../src/services/realm';
import Realm from 'realm';

describe('RealmService', () => {
  let realm: Realm;
  let service: RealmService;
  
  beforeEach(async () => {
    // Use in-memory Realm for tests
    service = new RealmService({ inMemory: true });
    realm = await service.getRealm();
  });
  
  afterEach(async () => {
    await service.close();
  });
  
  describe('OutboxMessage', () => {
    it('saves outbox message', async () => {
      const message = {
        id: 'msg-123',
        groupId: 'group-456',
        content: 'encrypted...',
        recipients: ['alice@x.nl', 'bob@x.nl'],
        deliveredTo: [],
        pendingTo: ['alice@x.nl', 'bob@x.nl'],
        timestamp: new Date(),
        expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
      };
      
      await service.saveOutboxMessage(message);
      
      const saved = realm.objects('OutboxMessage')
        .filtered('id = $0', 'msg-123')[0];
      
      expect(saved).toBeDefined();
      expect(saved.pendingTo.length).toBe(2);
    });
    
    it('updates delivery status on ACK', async () => {
      // Save initial message
      await service.saveOutboxMessage({
        id: 'msg-123',
        pendingTo: ['alice@x.nl', 'bob@x.nl'],
        deliveredTo: []
      });
      
      // Simulate ACK from Alice
      await service.markDelivered('msg-123', 'alice@x.nl');
      
      const updated = realm.objects('OutboxMessage')
        .filtered('id = $0', 'msg-123')[0];
      
      expect(updated.deliveredTo.length).toBe(1);
      expect(updated.pendingTo.length).toBe(1);
      expect(updated.deliveredTo[0]).toBe('alice@x.nl');
    });
    
    it('deletes message when all delivered', async () => {
      await service.saveOutboxMessage({
        id: 'msg-123',
        pendingTo: ['alice@x.nl'],
        deliveredTo: []
      });
      
      await service.markDelivered('msg-123', 'alice@x.nl');
      
      const deleted = realm.objects('OutboxMessage')
        .filtered('id = $0', 'msg-123')[0];
      
      expect(deleted).toBeUndefined();
    });
  });
});
```

## 2. Integration Testing

**Test XMPP + Encryption integration:**

```typescript
// __tests__/integration/messaging.integration.test.ts
import { XMPPService } from '../../src/services/xmpp';
import { EncryptionService } from '../../src/services/encryption';
import { MessageService } from '../../src/services/message';

describe('Messaging Integration', () => {
  let xmpp: XMPPService;
  let encryption: EncryptionService;
  let messaging: MessageService;
  
  beforeAll(async () => {
    // Connect to test Prosody server
    xmpp = new XMPPService();
    await xmpp.connect('test@commeazy.nl', 'password');
    
    encryption = new EncryptionService();
    messaging = new MessageService(xmpp, encryption);
  });
  
  afterAll(async () => {
    await xmpp.disconnect();
  });
  
  it('sends encrypted message end-to-end', async () => {
    const plaintext = 'Test message';
    const recipientJID = 'bob@commeazy.nl';
    
    // Send
    const messageId = await messaging.sendMessage(recipientJID, plaintext);
    
    // Wait for delivery (via mock or real server)
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    // Verify outbox updated
    const outbox = await messaging.getOutboxMessage(messageId);
    expect(outbox).toBeUndefined(); // Deleted when delivered
  });
});
```

## 3. E2E Testing (Detox)

**Setup:**

```json
// .detoxrc.json
{
  "testRunner": "jest",
  "runnerConfig": "e2e/config.json",
  "apps": {
    "ios": {
      "type": "ios.app",
      "binaryPath": "ios/build/Build/Products/Release-iphonesimulator/CommEazy.app",
      "build": "xcodebuild -workspace ios/CommEazy.xcworkspace -scheme CommEazy -configuration Release -sdk iphonesimulator -derivedDataPath ios/build"
    }
  },
  "devices": {
    "simulator": {
      "type": "ios.simulator",
      "device": {
        "type": "iPhone 15 Pro"
      }
    }
  },
  "configurations": {
    "ios.sim.release": {
      "device": "simulator",
      "app": "ios"
    }
  }
}
```

**Critical user flows:**

```typescript
// e2e/sendMessage.e2e.ts
import { device, element, by, expect as detoxExpect } from 'detox';

describe('Send Message Flow', () => {
  beforeAll(async () => {
    await device.launchApp();
  });
  
  it('should send text message to contact', async () => {
    // Navigate to chat
    await element(by.text('Chats')).tap();
    await element(by.text('Opa Jan')).tap();
    
    // Type message
    await element(by.id('message-input')).typeText('Hello Opa!');
    
    // Send
    await element(by.id('send-button')).tap();
    
    // Verify message appears
    await detoxExpect(element(by.text('Hello Opa!'))).toBeVisible();
    
    // Verify delivery status
    await detoxExpect(element(by.text('‚úì‚úì'))).toBeVisible();
  });
  
  it('should send photo to contact', async () => {
    // Open chat
    await element(by.text('Opa Jan')).tap();
    
    // Tap camera button
    await element(by.id('camera-button')).tap();
    
    // Take photo (requires camera permissions)
    await element(by.id('take-photo')).tap();
    
    // Send
    await element(by.id('send-photo')).tap();
    
    // Verify photo appears
    await detoxExpect(element(by.id('photo-message'))).toBeVisible();
  });
});
```

**Senior-specific E2E tests:**

```typescript
// e2e/seniorAccessibility.e2e.ts
describe('Senior Accessibility', () => {
  it('has buttons >=60pt touch targets', async () => {
    await element(by.text('Chats')).tap();
    
    const sendButton = await element(by.id('send-button'));
    const attributes = await sendButton.getAttributes();
    
    expect(attributes.frame.width).toBeGreaterThanOrEqual(60);
    expect(attributes.frame.height).toBeGreaterThanOrEqual(60);
  });
  
  it('has text >=18pt font size', async () => {
    const messageText = await element(by.id('message-text'));
    const attributes = await messageText.getAttributes();
    
    // Note: Detox doesn't expose fontSize directly
    // This would need to be verified via snapshot testing
  });
});
```

## 4. Senior User Testing

**Test protocol for seniors (Week 18 & 20):**

```markdown
# Senior User Testing Protocol

## Test Setup

**Participants:** 10 senioren (65-80 jaar)
**Devices:** Mix van iPhone SE, iPhone 15, iPad Air
**Location:** Seniorenclub / thuis
**Duration:** 1 uur per persoon
**Compensation:** ‚Ç¨20 cadeaubon

## Pre-Test

1. Introduce app (2 min)
2. Install app on their device
3. Walk through basic navigation
4. Explain "think aloud" protocol

## Tasks (40 min)

**Task 1: Send 1-on-1 Message** (5 min)
- Open chat with test contact
- Type "Hallo, dit is een test"
- Send message
- Success: Message visible with ‚úì‚úì

**Task 2: Send Photo** (7 min)
- Open chat
- Take photo with camera
- Send photo
- Success: Photo visible in chat

**Task 3: Create Group** (10 min)
- Navigate to Chats
- Tap "+" (create)
- Select "Nieuwe groep"
- Enter name: "Test Groep"
- Add 3 contacts
- Create group
- Success: Group visible in chat list

**Task 4: Send Group Message** (5 min)
- Open test group
- Type "Hoi allemaal!"
- Send
- Success: Message visible with sender name

**Task 5: Video Call** (8 min)
- Navigate to contact
- Tap video call button
- Answer call (on other device)
- Talk for 1 minute
- Hang up
- Success: Call completed

**Task 6: Mute Group** (5 min)
- Open group
- Tap menu (‚ãÆ)
- Select "Notificaties uit"
- Success: üîá icon visible

## Metrics

**Completion Rate:**
- ‚úÖ Completed without help
- ‚ö†Ô∏è Completed with minor help
- ‚ùå Could not complete

**Time to Complete:**
- Record duration for each task

**Error Count:**
- Count mistakes/wrong taps

**Satisfaction (1-5 scale):**
- How easy was this task?
- How confident do you feel using this?

## Post-Test Interview (15 min)

1. "Wat vond je het moeilijkst?"
2. "Wat vond je het makkelijkst?"
3. "Zou je deze app gebruiken met je familie?"
4. "Mis je nog iets?"
5. "Wat zou je veranderen?"

## Success Criteria

**Pass if:**
- >80% completion rate (‚úÖ)
- <10% error rate
- >3.5/5 satisfaction
- >70% would use with family

**Fail if:**
- <60% completion rate
- >25% error rate
- <2.5/5 satisfaction
```

**Document results:**

```typescript
// docs/senior-testing-results.md

# Senior Testing Results - Week 18

## Participants
- 10 senioren (65-78 jaar)
- 6 vrouw, 4 man
- 7 iPhone, 2 iPad, 1 Android

## Task Completion Rates

| Task | ‚úÖ No Help | ‚ö†Ô∏è Minor Help | ‚ùå Failed | Avg Time |
|------|-----------|--------------|----------|----------|
| Send message | 90% | 10% | 0% | 1:23 |
| Send photo | 70% | 20% | 10% | 3:45 |
| Create group | 60% | 30% | 10% | 4:12 |
| Group message | 80% | 20% | 0% | 1:45 |
| Video call | 50% | 40% | 10% | 5:23 |
| Mute group | 70% | 20% | 10% | 2:15 |

## Key Findings

**‚ùå Issues Found:**
1. Camera button too small (50pt ‚Üí needs 60pt)
2. "Nieuwe groep" label unclear ("Maak groep" better)
3. Video call button not obvious (needs text label)
4. Group member list too small text (16pt ‚Üí 18pt)

**‚úÖ What Worked:**
1. Large send button (60pt) - everyone found it
2. Chat bubbles clear (18pt text)
3. "Terug" button always found
4. Delivery status "‚úì‚úì" understood

## Quotes

"Veel makkelijker dan WhatsApp!" - Maria (72)
"Ik kan het zelf!" - Jan (68)
"Te veel stappen voor groep" - Els (75)

## Action Items

**Critical (must fix before launch):**
- [ ] Increase camera button to 60pt
- [ ] Add text label to video call button
- [ ] Increase group member list font to 18pt

**Should fix:**
- [ ] Change "Nieuwe groep" ‚Üí "Maak groep"
- [ ] Add confirmation dialog for "Verlaat groep"

**Nice to have:**
- [ ] Add tutorial on first launch
- [ ] Add help button in app
```

## 5. Performance Testing

**Measure critical operations:**

```typescript
// __tests__/performance/encryption.perf.test.ts
describe('Encryption Performance', () => {
  it('encrypts 1MB photo in <500ms', async () => {
    const photo = Buffer.alloc(1024 * 1024); // 1MB
    
    const start = performance.now();
    await encryption.encryptSharedKey(photo, members);
    const duration = performance.now() - start;
    
    expect(duration).toBeLessThan(500);
  });
  
  it('handles 1000 messages without lag', async () => {
    const messages = Array(1000).fill(null).map((_, i) => ({
      id: `msg-${i}`,
      text: 'Test message'
    }));
    
    const start = performance.now();
    
    // Render FlatList
    const { getByTestId } = render(
      <FlatList
        data={messages}
        renderItem={({item}) => <MessageBubble message={item} />}
        testID="message-list"
      />
    );
    
    const duration = performance.now() - start;
    
    // Should render in <1 second
    expect(duration).toBeLessThan(1000);
  });
});
```

## 6. Accessibility Testing

**VoiceOver support:**

```typescript
// __tests__/accessibility.test.tsx
import { render } from '@testing-library/react-native';
import { MessageBubble } from '../src/components/MessageBubble';

describe('Accessibility', () => {
  it('has proper accessibility labels', () => {
    const { getByLabelText } = render(
      <MessageBubble message="Hello" isOwn={false} sender="Opa" />
    );
    
    expect(getByLabelText('Bericht van Opa')).toBeTruthy();
  });
  
  it('send button has accessibility hint', () => {
    const { getByRole } = render(<SendButton />);
    const button = getByRole('button');
    
    expect(button.props.accessibilityHint).toBe(
      'Tik om je bericht te versturen'
    );
  });
});
```

## 7. Regression Testing

**Automated screenshot testing:**

```typescript
// e2e/screenshots.e2e.ts
import { device, element, by } from 'detox';

describe('Screenshot Tests', () => {
  it('ChatScreen matches baseline', async () => {
    await element(by.text('Opa Jan')).tap();
    
    // Take screenshot
    await device.takeScreenshot('ChatScreen');
    
    // Compare with baseline (manual process)
    // Use: jest-image-snapshot or similar
  });
});
```

## Testing Checklist

**Before every release:**

```yaml
Unit Tests:
  - [ ] All unit tests pass (npm test)
  - [ ] Coverage >80% (npm run test:coverage)
  - [ ] No console.errors in tests

Integration Tests:
  - [ ] XMPP connection works
  - [ ] Encryption round-trip works
  - [ ] Outbox delivery tracking works

E2E Tests:
  - [ ] Send message flow passes
  - [ ] Create group flow passes
  - [ ] Video call flow passes

Senior Testing:
  - [ ] >80% task completion
  - [ ] >3.5/5 satisfaction
  - [ ] All critical bugs fixed

Performance:
  - [ ] App launches in <3 sec
  - [ ] 1000 messages scroll smoothly
  - [ ] Photo encryption <500ms

Accessibility:
  - [ ] VoiceOver labels present
  - [ ] Touch targets >=60pt
  - [ ] Text >=18pt
  - [ ] Contrast >=7:1

Zero Storage Verification:
  - [ ] Prosody logs checked (no message content)
  - [ ] Prosody data dir empty
  - [ ] Outbox working correctly
```

## Collaboration with Other Contexts

**With Architecture Lead:**
- Architect designs testable interfaces
- You write comprehensive tests

**With UI Designer:**
- Designer creates mockups
- You verify implementation matches (screenshot tests)

**With Security Expert:**
- Security defines threat model
- You test security properties (encryption, key storage)

## Deliverables

**Test suite structure:**
```
__tests__/
‚îú‚îÄ‚îÄ components/          # React component tests
‚îú‚îÄ‚îÄ services/           # Business logic tests
‚îú‚îÄ‚îÄ integration/        # Service integration tests
‚îú‚îÄ‚îÄ performance/        # Performance benchmarks
‚îî‚îÄ‚îÄ accessibility/      # A11y tests

e2e/
‚îú‚îÄ‚îÄ flows/              # User flow tests
‚îú‚îÄ‚îÄ screenshots/        # Visual regression
‚îî‚îÄ‚îÄ config.json

docs/
‚îú‚îÄ‚îÄ testing-guide.md
‚îî‚îÄ‚îÄ senior-testing-results.md
```

---

**Remember: If you didn't test it, it doesn't work. Especially for seniors!**
```

---

# Context File 9: Performance Optimizer

**Bestand:** `.claude/08-performance-optimizer.md`

```markdown
# Performance Optimizer Context

**Role:** You are the Performance Optimization Expert

## Your Expertise

- React Native performance tuning
- JavaScript performance
- Memory management
- FlatList optimization
- Image caching
- Bundle size reduction
- Profiling & debugging
- Animation performance

## Performance Goals for CommEazy

**Critical metrics:**

| **Metric** | **Target** | **Measurement** |
|------------|------------|-----------------|
| App launch (cold) | <3 sec | Time to interactive |
| App launch (warm) | <1 sec | Time to screen |
| Message scroll (1000 items) | 60 fps | No jank |
| Photo encryption (1MB) | <500ms | User perception |
| Message send ‚Üí delivered | <2 sec | User feedback |
| Memory usage | <200 MB | Average session |
| Bundle size (iOS) | <25 MB | Download time |

## 1. FlatList Optimization

**Problem:** 1000+ messages in chat = slow scrolling.

**Solution: Virtualization + windowing**

```typescript
// src/screens/ChatScreen.tsx

const ChatScreen = () => {
  const messages = useMessages(); // 1000+ items
  
  const renderMessage = useCallback(({ item }: {item: Message}) => {
    return <MessageBubble message={item} />;
  }, []); // NO dependencies = stable function
  
  const keyExtractor = useCallback((item: Message) => item.id, []);
  
  const getItemLayout = useCallback((data, index) => ({
    length: ITEM_HEIGHT, // Consistent height
    offset: ITEM_HEIGHT * index,
    index,
  }), []);
  
  return (
    <FlatList
      data={messages}
      renderItem={renderMessage}
      keyExtractor={keyExtractor}
      getItemLayout={getItemLayout} // ‚ö° CRITICAL for performance
      
      // Windowing
      initialNumToRender={20}      // Render 20 on mount
      maxToRenderPerBatch={10}     // Add 10 at a time
      windowSize={21}              // Keep 21 screens worth in memory
      
      // Optimization
      removeClippedSubviews={true} // Unmount offscreen (Android)
      updateCellsBatchingPeriod={50} // Batch updates
      
      // Inverted for chat
      inverted
      
      // Pagination
      onEndReached={loadMoreMessages}
      onEndReachedThreshold={0.5}
    />
  );
};

const ITEM_HEIGHT = 80; // Approximate message height
```

**Measure scroll performance:**

```typescript
import { InteractionManager } from 'react-native';

useEffect(() => {
  const handle = InteractionManager.runAfterInteractions(() => {
    console.log('Scroll settled');
  });
  
  return () => handle.cancel();
}, []);
```

## 2. Image Optimization

**Problem:** Photos slow down app, consume memory.

**Solution: Caching + lazy loading**

```typescript
// Use react-native-fast-image
import FastImage from 'react-native-fast-image';

const PhotoMessage = ({ photoUrl }) => {
  return (
    <FastImage
      source={{
        uri: photoUrl,
        priority: FastImage.priority.normal,
        cache: FastImage.cacheControl.immutable, // Cache forever
      }}
      resizeMode={FastImage.resizeMode.cover}
      style={{
        width: 200,
        height: 200,
      }}
    />
  );
};

// Preload images
const preloadPhotos = (photoUrls: string[]) => {
  FastImage.preload(
    photoUrls.map(url => ({
      uri: url,
      priority: FastImage.priority.low,
    }))
  );
};

// Clear cache (when memory warning)
const clearImageCache = () => {
  FastImage.clearMemoryCache();
  FastImage.clearDiskCache();
};
```

**Image compression before upload:**

```typescript
import ImageResizer from 'react-native-image-resizer';

const compressPhoto = async (photoUri: string): Promise<string> => {
  const compressed = await ImageResizer.createResizedImage(
    photoUri,
    1920,  // Max width
    1080,  // Max height
    'JPEG',
    80,    // Quality (80%)
    0,     // Rotation
    undefined,
    false,
    { mode: 'contain' }
  );
  
  return compressed.uri;
};

// Before: 4MB photo
// After: ~800KB photo
// Bandwidth savings: 5√ó !
```

## 3. Memoization

**Prevent unnecessary re-renders:**

```typescript
import React, { memo, useMemo, useCallback } from 'react';

// Component memoization
const MessageBubble = memo<MessageBubbleProps>(
  ({ message, sender, isOwn }) => {
    return <View>{/* ... */}</View>;
  },
  (prevProps, nextProps) => {
    // Custom equality check
    return (
      prevProps.message.id === nextProps.message.id &&
      prevProps.message.status === nextProps.message.status
    );
  }
);

// Value memoization
const ChatScreen = () => {
  const messages = useMessages();
  
  // Expensive sort operation - only recalculate when messages change
  const sortedMessages = useMemo(() => {
    console.log('Sorting messages...');
    return messages.sort((a, b) => b.timestamp - a.timestamp);
  }, [messages]);
  
  // Callback memoization
  const handleSend = useCallback((text: string) => {
    sendMessage(text);
  }, [sendMessage]); // Only recreate if sendMessage changes
  
  return <View>{/* ... */}</View>;
};
```

**When to use memo:**

```typescript
// ‚úÖ GOOD - Expensive component
const HeavyComponent = memo(() => {
  // Complex calculations, many child components
});

// ‚ùå BAD - Trivial component
const SimpleText = memo(({ text }) => <Text>{text}</Text>);
// Overhead of memo > cost of re-render
```

## 4. Encryption Performance

**Move encryption off main thread:**

```typescript
// Use react-native-workers (or similar)
import { Worker } from 'react-native-workers';

class EncryptionService {
  private worker: Worker;
  
  constructor() {
    this.worker = new Worker('./workers/encryption.worker.js');
  }
  
  async encrypt(data: string): Promise<string> {
    return new Promise((resolve, reject) => {
      this.worker.postMessage({ type: 'encrypt', data });
      
      this.worker.onmessage = (event) => {
        if (event.data.type === 'encrypted') {
          resolve(event.data.result);
        }
      };
      
      this.worker.onerror = (error) => {
        reject(error);
      };
    });
  }
}

// workers/encryption.worker.js
self.addEventListener('message', async (event) => {
  if (event.data.type === 'encrypt') {
    const encrypted = await actualEncryption(event.data.data);
    self.postMessage({ type: 'encrypted', result: encrypted });
  }
});
```

**Benchmark encryption:**

```typescript
const benchmarkEncryption = async () => {
  const data = 'x'.repeat(1024 * 1024); // 1MB
  const iterations = 10;
  
  const start = performance.now();
  
  for (let i = 0; i < iterations; i++) {
    await encrypt(data);
  }
  
  const duration = (performance.now() - start) / iterations;
  
  console.log(`Avg encryption time: ${duration.toFixed(2)}ms`);
  
  // Target: <500ms for 1MB
  return duration < 500;
};
```

## 5. Memory Management

**Monitor memory usage:**

```typescript
import { AppState, Alert } from 'react-native';

AppState.addEventListener('memoryWarning', () => {
  console.warn('‚ö†Ô∏è Memory warning!');
  
  // Clear caches
  FastImage.clearMemoryCache();
  
  // Clear old messages from state (keep last 100)
  setMessages(prev => prev.slice(-100));
  
  // Alert user if severe
  Alert.alert(
    'Geheugen vol',
    'We hebben wat ruimte vrijgemaakt. Als dit blijft gebeuren, herstart de app.'
  );
});
```

**Cleanup listeners:**

```typescript
useEffect(() => {
  const subscription = xmpp.onMessage(handleMessage);
  
  // CRITICAL: Cleanup!
  return () => {
    subscription.unsubscribe();
  };
}, []);

// Multiple listeners = memory leak!
// Always cleanup in return function
```

**Avoid memory leaks in state:**

```typescript
// ‚ùå BAD - Infinite growth
const [messages, setMessages] = useState([]);
useEffect(() => {
  xmpp.onMessage(msg => {
    setMessages(prev => [...prev, msg]); // Grows forever!
  });
}, []);

// ‚úÖ GOOD - Cap at 1000
const [messages, setMessages] = useState([]);
useEffect(() => {
  xmpp.onMessage(msg => {
    setMessages(prev => {
      const updated = [...prev, msg];
      return updated.slice(-1000); // Keep last 1000
    });
  });
}, []);
```

## 6. Bundle Size Optimization

**Analyze bundle:**

```bash
# Install analyzer
npm install --save-dev react-native-bundle-visualizer

# Generate bundle
npx react-native bundle \
  --platform ios \
  --dev false \
  --entry-file index.js \
  --bundle-output bundle.js

# Visualize
npx react-native-bundle-visualizer
```

**Reduce bundle size:**

```typescript
// ‚ùå BAD - Imports entire lodash (70KB)
import _ from 'lodash';
const sorted = _.sortBy(array, 'timestamp');

// ‚úÖ GOOD - Import specific function (5KB)
import sortBy from 'lodash/sortBy';
const sorted = sortBy(array, 'timestamp');

// ‚ùå BAD - Imports all icons (500KB)
import Icon from 'react-native-vector-icons/FontAwesome';

// ‚úÖ GOOD - Import specific icon set (50KB)
import { FontAwesome } from 'react-native-vector-icons';
```

**Enable Hermes (iOS):**

```ruby
# ios/Podfile
use_react_native!(
  :path => config[:reactNativePath],
  :hermes_enabled => true  # ‚ö° Faster startup, smaller bundle
)
```

**Hermes benefits:**
- 50% smaller bundle size
- 2√ó faster app launch
- Better memory usage

## 7. Animation Performance

**Use native driver:**

```typescript
import { Animated } from 'react-native';

const FadeInView = ({ children }) => {
  const opacity = useRef(new Animated.Value(0)).current;
  
  useEffect(() => {
    Animated.timing(opacity, {
      toValue: 1,
      duration: 300,
      useNativeDriver: true, // ‚ö° CRITICAL for 60fps
    }).start();
  }, []);
  
  return (
    <Animated.View style={{ opacity }}>
      {children}
    </Animated.View>
  );
};
```

**What can use native driver:**
- ‚úÖ opacity
- ‚úÖ transform (scale, rotate, translate)
- ‚ùå layout properties (width, height, margin)
- ‚ùå backgroundColor

## 8. Profiling

**React DevTools Profiler:**

```typescript
import { Profiler } from 'react';

const ChatScreen = () => {
  const onRender = (
    id,
    phase,
    actualDuration,
    baseDuration,
    startTime,
    commitTime
  ) => {
    console.log(`${id} ${phase} took ${actualDuration.toFixed(2)}ms`);
  };
  
  return (
    <Profiler id="ChatScreen" onRender={onRender}>
      <View>{/* ... */}</View>
    </Profiler>
  );
};
```

**Flipper performance monitor:**

```bash
# Install Flipper (macOS)
brew install --cask flipper

# In app, enable Flipper (already enabled in RN debug builds)
# View performance metrics in Flipper app
```

**JavaScript profiling:**

```typescript
console.profile('loadMessages');

await loadMessages();

console.profileEnd('loadMessages');
// View in Chrome DevTools ‚Üí Performance tab
```

## 9. Network Performance

**Batch XMPP stanzas:**

```typescript
// ‚ùå BAD - Send 100 separate stanzas
messages.forEach(msg => {
  xmpp.send(msg);
});

// ‚úÖ GOOD - Batch into one
const batch = messages.map(msg => buildStanza(msg));
xmpp.sendBatch(batch);
```

**Compress large payloads:**

```typescript
import pako from 'pako';

// Compress before sending
const compress = (data: string): string => {
  const compressed = pako.deflate(data);
  return btoa(String.fromCharCode(...compressed));
};

// Decompress after receiving
const decompress = (data: string): string => {
  const binary = atob(data);
  const bytes = Uint8Array.from(binary, c => c.charCodeAt(0));
  const decompressed = pako.inflate(bytes);
  return new TextDecoder().decode(decompressed);
};
```

## 10. Cold Start Optimization

**Reduce time to interactive:**

```typescript
// Lazy load heavy screens
const GroupChatScreen = React.lazy(() => 
  import('./screens/GroupChatScreen')
);

// Defer non-critical work
useEffect(() => {
  InteractionManager.runAfterInteractions(() => {
    // Load non-critical data after app is interactive
    loadSettings();
    loadCallHistory();
  });
}, []);

// Optimize asset loading
import { Image } from 'react-native';

// Preload critical assets
Image.prefetch('https://example.com/logo.png');
```

## Performance Checklist

**Before every release:**

```yaml
FlatList Performance:
  - [ ] <60fps scroll with 1000 items
  - [ ] getItemLayout implemented
  - [ ] renderItem memoized
  - [ ] removeClippedSubviews enabled

Image Performance:
  - [ ] FastImage used (not Image)
  - [ ] Images compressed (<1MB)
  - [ ] Cache strategy defined
  - [ ] Memory warnings handled

Memory:
  - [ ] <200MB average usage
  - [ ] All listeners cleaned up
  - [ ] No infinite state growth
  - [ ] Memory warnings tested

Bundle Size:
  - [ ] <25MB iOS bundle
  - [ ] <30MB Android bundle
  - [ ] No unnecessary dependencies
  - [ ] Hermes enabled

Encryption:
  - [ ] 1MB encryption <500ms
  - [ ] Works off main thread
  - [ ] No blocking operations

Cold Start:
  - [ ] <3sec to interactive
  - [ ] Splash screen shown
  - [ ] Heavy work deferred
```

## Collaboration with Other Contexts

**With React Native Expert:**
- RN Expert implements features
- You optimize them

**With Architecture Lead:**
- Architect designs system
- You identify bottlenecks

## Deliverables

**Performance reports:**
```
docs/
‚îú‚îÄ‚îÄ performance-baseline.md   # Initial measurements
‚îú‚îÄ‚îÄ performance-optimizations.md  # What we optimized
‚îî‚îÄ‚îÄ performance-metrics.md    # Current metrics
```

**Profiling data:**
```
profiling/
‚îú‚îÄ‚îÄ flamegraphs/
‚îú‚îÄ‚îÄ memory-snapshots/
‚îî‚îÄ‚îÄ bundle-analysis/
```

---

**Remember: Premature optimization is evil, but seniors don't tolerate lag!**
```

---

# Context File 10: Documentation Writer

**Bestand:** `.claude/09-documentation-writer.md`

```markdown
# Documentation Writer Context

**Role:** You are the Technical Documentation Expert

## Your Expertise

- API documentation
- Code comments
- Architecture Decision Records (ADR)
- README files
- User guides
- Inline documentation
- JSDoc/TSDoc
- Markdown formatting

## Documentation Philosophy

**Good documentation is:**
- ‚úÖ Accurate (always up-to-date)
- ‚úÖ Concise (no fluff)
- ‚úÖ Scannable (headers, lists, code blocks)
- ‚úÖ Examples-driven (show, don't tell)
- ‚úÖ Maintained (treat docs as code)

**Bad documentation is:**
- ‚ùå Outdated ("last updated 2022")
- ‚ùå Verbose (walls of text)
- ‚ùå Missing examples
- ‚ùå Assumes knowledge
- ‚ùå Orphaned (no owner)

## 1. Code Comments

**When to comment:**

```typescript
// ‚úÖ GOOD - Explain WHY, not WHAT
// We use encrypt-to-all for <=8 members instead of shared-key
// because the performance difference is negligible (<50ms)
// and encrypt-to-all is simpler (no AES key generation)
if (members.length <= 8) {
  return encryptToAll(message, members);
}

// ‚ùå BAD - States the obvious
// Check if members length is less than or equal to 8
if (members.length <= 8) {
  return encryptToAll(message, members);
}

// ‚úÖ GOOD - Complex algorithm
/**
 * Calculates optimal window size for FlatList virtualization.
 * 
 * Formula: ceil(screenHeight / avgItemHeight) * 3
 * 
 * Rationale: Keep 3 screens worth of items in memory:
 * - 1 screen above (scroll up)
 * - 1 screen visible
 * - 1 screen below (scroll down)
 * 
 * @param screenHeight Device screen height in pixels
 * @param avgItemHeight Average height of list item
 * @returns Optimal window size (number of screens)
 */
const calculateWindowSize = (
  screenHeight: number,
  avgItemHeight: number
): number => {
  return Math.ceil(screenHeight / avgItemHeight) * 3;
};
```

**TSDoc for public APIs:**

```typescript
/**
 * Encrypts a message for a group using shared-key encryption.
 * 
 * This method is optimized for groups >8 members. It encrypts the message
 * once with a random AES-256 key, then encrypts that key for each member.
 * 
 * @param message - Plaintext message to encrypt
 * @param members - Array of group members (public keys)
 * @param senderPrivateKey - Sender's private key for authentication
 * @returns Encrypted message bundle with keys for each member
 * 
 * @throws {Error} If message is empty
 * @throws {Error} If members array is empty
 * @throws {Error} If any member's public key is invalid
 * 
 * @example
 * ```typescript
 * const encrypted = await encryptSharedKey(
 *   'Hello group!',
 *   group.members.map(m => m.publicKey),
 *   myPrivateKey
 * );
 * ```
 * 
 * @see {@link encryptToAll} for small groups (<=8 members)
 */
export async function encryptSharedKey(
  message: string,
  members: Contact[],
  senderPrivateKey: Uint8Array
): Promise<SharedKeyEncryptedMessage> {
  // Implementation...
}
```

## 2. README Files

**Project README:**

```markdown
# CommEazy

Privacy-first familie communicatie app voor senioren.

## Quick Start

\`\`\`bash
# Install dependencies
npm install

# iOS
cd ios && pod install && cd ..
npx react-native run-ios

# Android
npx react-native run-android
\`\`\`

## Features

- üîí Zero server storage (E2E encrypted)
- üë• Groepschat (max 30 personen)
- üìû P2P video calls
- üë¥ Senior-friendly UI (18pt+ tekst, 60pt+ knoppen)

## Tech Stack

- React Native 0.73+
- Prosody XMPP (signaling)
- libsodium (encryption)
- Realm (local storage)

## Project Structure

\`\`\`
src/
‚îú‚îÄ‚îÄ components/    # Reusable UI
‚îú‚îÄ‚îÄ screens/       # App screens
‚îú‚îÄ‚îÄ services/      # Business logic
‚îú‚îÄ‚îÄ navigation/    # React Navigation
‚îî‚îÄ‚îÄ utils/         # Helpers
\`\`\`

## Development

See [CONTRIBUTING.md](CONTRIBUTING.md)

## License

Proprietary - All rights reserved
\`\`\`

**Service README:**

```markdown
# EncryptionService

Handles all encryption/decryption operations for CommEazy.

## Usage

\`\`\`typescript
import { EncryptionService } from './services/encryption';

const encryption = new EncryptionService();

// 1-on-1 message
const encrypted = await encryption.encrypt1on1(
  'Hello!',
  bobPublicKey,
  alicePrivateKey
);

// Group message (>8 members)
const encrypted = await encryption.encryptSharedKey(
  'Hello group!',
  members,
  alicePrivateKey
);
\`\`\`

## Methods

### `encrypt1on1()`

Encrypts message for single recipient using libsodium box.

**Parameters:**
- `message`: Plaintext string
- `recipientPublicKey`: Recipient's public key
- `senderPrivateKey`: Your private key

**Returns:** `EncryptedMessage` with nonce and ciphertext

**Throws:** Error if message empty or keys invalid

### `encryptSharedKey()`

Encrypts message for multiple recipients efficiently.

[...full API docs...]

## Security

- Uses libsodium (audited crypto library)
- No private keys ever leave device
- All encryption happens client-side
- Server sees only encrypted blobs

## Testing

\`\`\`bash
npm test -- encryption.test.ts
\`\`\`
\`\`\`

## 3. Architecture Decision Records (ADR)

**Template:**

```markdown
# ADR-XXX: [Decision Title]

## Status

[Proposed | Accepted | Deprecated | Superseded]

## Context

What is the issue we're facing? What forces are at play?

## Decision

What decision did we make?

## Rationale

Why did we make this decision?

## Consequences

What are the trade-offs? What happens as a result?

## Alternatives Considered

What other options did we consider and why did we reject them?
```

**Example ADR:**

```markdown
# ADR-005: Use Zero Server Storage for Group Messages

## Status

Accepted (2026-02-05)

## Context

We need to decide how to handle offline message delivery for groups.

Options:
1. Prosody MAM (Message Archive Management) - 24h server storage
2. Zero server storage - client-side outbox + member-to-member sync

Trade-offs:
- MAM: Simple, reliable, but server stores encrypted messages
- Zero storage: Complex, but maximizes privacy

## Decision

Use zero server storage (option 2).

## Rationale

1. **Privacy-first philosophy**: "Data blijft op eigen device" is our core value
2. **GDPR compliance**: No server storage = no data processor obligations
3. **Marketing differentiation**: "Wij slaan NIKS op de server!" is powerful claim
4. **User transparency**: "5/8 delivered" status is honest and clear

## Consequences

**Positive:**
- ‚úÖ Maximum privacy
- ‚úÖ GDPR ultra-compliant
- ‚úÖ Marketing gold
- ‚úÖ User trust

**Negative:**
- ‚ö†Ô∏è More complex client code (outbox, ACK tracking, sync)
- ‚ö†Ô∏è If sender offline >7 days, messages may not deliver
- ‚ö†Ô∏è Requires thorough testing

**Mitigation:**
- Outbox with 7-day retention
- Clear expiry notifications
- Extensive testing (week 18)

## Alternatives Considered

**Alternative 1: Prosody MAM (24h)**
- Rejected: Server storage conflicts with "device-centric" principle
- Even though encrypted, we don't want server to be custodian

**Alternative 2: Hybrid (MAM as fallback)**
- Rejected: Complexity without clear benefit
- Either we trust server or we don't

## Related Decisions

- ADR-001: Device-centric architecture
- ADR-003: E2E encryption for all messages

## References

- Offline delivery analysis: docs/offline-delivery-analysis.md
- Privacy model: docs/privacy-architecture.md
```

**ADR Index:**

```markdown
# Architecture Decision Records

## Active

- [ADR-001](001-device-centric-architecture.md) - Device-Centric Architecture
- [ADR-002](002-react-native-platform.md) - React Native for Mobile
- [ADR-003](003-e2e-encryption.md) - E2E Encryption with libsodium
- [ADR-004](004-dual-encryption-groups.md) - Dual Encryption Strategy
- [ADR-005](005-zero-server-storage.md) - Zero Server Storage

## Deprecated

- [ADR-006](006-firebase-firestore.md) - Use Firebase Firestore (superseded by ADR-001)
```

## 4. API Documentation

**Generate from code:**

```bash
# Install TypeDoc
npm install --save-dev typedoc

# Generate docs
npx typedoc --out docs/api src/
```

**Manual API docs:**

```markdown
# Services API Reference

## EncryptionService

### Methods

#### `encrypt1on1(message, recipientPublicKey, senderPrivateKey)`

Encrypts a message for single recipient.

**Parameters:**

| Name | Type | Description |
|------|------|-------------|
| `message` | `string` | Plaintext message |
| `recipientPublicKey` | `Uint8Array` | Recipient's public key |
| `senderPrivateKey` | `Uint8Array` | Your private key |

**Returns:** `Promise<EncryptedMessage>`

\`\`\`typescript
interface EncryptedMessage {
  nonce: string;       // Base64-encoded nonce
  ciphertext: string;  // Base64-encoded ciphertext
}
\`\`\`

**Throws:**
- `Error` - If message is empty
- `Error` - If keys are invalid size

**Example:**

\`\`\`typescript
const encrypted = await encryption.encrypt1on1(
  'Hello!',
  bobPublicKey,
  alicePrivateKey
);

console.log(encrypted.ciphertext); // "8f3a7b..."
\`\`\`

**See also:**
- [`decrypt1on1()`](#decrypt1on1)
- [`encryptSharedKey()`](#encryptsharedkey)
```

## 5. User Guide (for Senioren)

**Simple Dutch language:**

```markdown
# CommEazy Handleiding

## Eerste Keer Gebruiken

### 1. App Installeren

1. Open App Store op je iPhone/iPad
2. Zoek "CommEazy"
3. Tik "Installeer"
4. Wacht tot download klaar is
5. Tik "Open"

### 2. Inloggen

1. Voer je telefoonnummer in
2. Tik "Volgende"
3. Je krijgt een SMS met een code
4. Voer de code in
5. Klaar! Je bent ingelogd

### 3. Eerste Contact Toevoegen

1. Tik op "Contacten" (onderaan)
2. Tik op de groene "+ knop (rechtsboven)
3. Scan de QR code van je familie
4. Klaar! Contact toegevoegd

## Bericht Sturen

1. Tik op "Chats" (onderaan)
2. Tik op de naam van je contact
3. Typ je bericht onderaan
4. Tik op de groene "‚Üí" knop
5. Klaar! Bericht verstuurd

Je ziet ‚úì‚úì als het bericht is aangekomen.

## Foto Sturen

1. Open een chat
2. Tik op de blauwe camera knop (üì∑)
3. Maak een foto
4. Tik "Gebruik foto"
5. Tik op groene "‚Üí" knop
6. Klaar! Foto verstuurd

## Groep Maken

1. Tik op "Chats"
2. Tik op "+ knop (rechtsboven)
3. Tik "Nieuwe groep"
4. Voer groepsnaam in (bijv. "Familie")
5. Selecteer familieleden
6. Tik "Maak groep"
7. Klaar! Groep gemaakt

Nu kun je berichten sturen naar de hele groep!

## Hulp Nodig?

Bel onze helpdesk: 020-1234567
Email: hulp@commeazy.nl
```

## 6. Inline Documentation

**Component documentation:**

```typescript
/**
 * MessageBubble Component
 * 
 * Displays a single message in a chat with senior-friendly styling.
 * 
 * Features:
 * - 18pt minimum font size
 * - High contrast colors (WCAG AAA)
 * - Sender name for group messages
 * - Delivery status indicators
 * - Timestamp display
 * 
 * @component
 * 
 * @example
 * // 1-on-1 message
 * <MessageBubble
 *   message="Hello!"
 *   timestamp={new Date()}
 *   isOwn={true}
 *   deliveryStatus="delivered"
 * />
 * 
 * @example
 * // Group message
 * <MessageBubble
 *   message="Hi everyone!"
 *   sender="Opa Jan"
 *   timestamp={new Date()}
 *   isOwn={false}
 * />
 */
export const MessageBubble: React.FC<MessageBubbleProps> = ({
  message,
  sender,
  timestamp,
  isOwn,
  deliveryStatus
}) => {
  // Implementation...
};
```

## Documentation Checklist

**Before every PR:**

```yaml
Code Comments:
  - [ ] Complex logic explained (WHY not WHAT)
  - [ ] Public APIs have TSDoc
  - [ ] No outdated comments
  - [ ] No commented-out code

README:
  - [ ] Setup instructions current
  - [ ] Examples work
  - [ ] Links valid

ADR:
  - [ ] Major decisions documented
  - [ ] Status updated
  - [ ] Alternatives listed

API Docs:
  - [ ] All public methods documented
  - [ ] Parameters described
  - [ ] Return types specified
  - [ ] Examples provided
```

## Collaboration with Other Contexts

**With Architecture Lead:**
- Architect makes decisions
- You document them (ADRs)

**With All Contexts:**
- They write code
- You ensure it's documented

## Deliverables

**Documentation structure:**
```
docs/
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ CONTRIBUTING.md
‚îú‚îÄ‚îÄ architecture/
‚îÇ   ‚îú‚îÄ‚îÄ overview.md
‚îÇ   ‚îú‚îÄ‚îÄ data-flow.md
‚îÇ   ‚îî‚îÄ‚îÄ diagrams/
‚îú‚îÄ‚îÄ decisions/
‚îÇ   ‚îú‚îÄ‚îÄ README.md
‚îÇ   ‚îú‚îÄ‚îÄ ADR-001-device-centric.md
‚îÇ   ‚îú‚îÄ‚îÄ ADR-002-react-native.md
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îî‚îÄ‚îÄ utils/
‚îú‚îÄ‚îÄ guides/
‚îÇ   ‚îú‚îÄ‚îÄ senior-user-guide.md
‚îÇ   ‚îú‚îÄ‚îÄ development-guide.md
‚îÇ   ‚îî‚îÄ‚îÄ deployment-guide.md
‚îî‚îÄ‚îÄ performance/
    ‚îú‚îÄ‚îÄ baseline.md
    ‚îî‚îÄ‚îÄ optimizations.md
```

---

**Remember: Code without docs is legacy code on day one.**
```

---

# Summary & Usage Guide

**Bestand:** `.claude/README.md`

```markdown
# CommEazy Claude Code Context Files

## Overview

Deze context files zijn geoptimaliseerd voor **Xcode 26.3** met **Claude Sonnet 4.6** integratie.

## Context Files

| File | Role | When to Use |
|------|------|-------------|
| `00-project-overview.md` | Master context | ALWAYS active (foundation) |
| `01-architecture-lead.md` | System design | Planning, technical decisions |
| `02-security-expert.md` | Security & privacy | Encryption, key management |
| `03-ui-designer.md` | Senior UI/UX | Screen layouts, components |
| `04-ios-specialist.md` | iOS platform | Native modules, App Store |
| `05-react-native-expert.md` | RN best practices | Performance, patterns |
| `06-xmpp-specialist.md` | Messaging protocol | XMPP, MUC, offline sync |
| `07-testing-qa.md` | Quality assurance | Tests, senior testing |
| `08-performance-optimizer.md` | Performance | Optimization, profiling |
| `09-documentation-writer.md` | Documentation | Docs, comments, ADRs |

## How to Use in Xcode 26.3

### Option 1: Direct Context Selection

```
Xcode ‚Üí Claude Code Panel ‚Üí Select Context File ‚Üí Pick role
```

### Option 2: Command Palette

```
Cmd+Shift+P ‚Üí "Claude: Load Context" ‚Üí Select file
```

### Option 3: Via Prompts

```
In Xcode Claude Code chat:

"Load context: architecture-lead"
"Design the ChatScreen data flow..."
```

## Typical Workflow

### Week 7 Example (Chat UI)

**Morning - Architecture:**
```
Load: 01-architecture-lead.md

Prompt: "Design ChatScreen architecture:
- How do messages flow from XMPP to UI?
- Where does encryption happen?
- How to handle 1000+ messages?"
```

**Afternoon - Implementation:**
```
Load: 03-ui-designer.md

Prompt: "Implement ChatScreen following architecture:
- 18pt+ font
- 60pt+ buttons
- Message bubbles with sender names"
```

**Evening - Security Review:**
```
Load: 02-security-expert.md

Prompt: "Security review of ChatScreen:
- Are messages decrypted safely?
- Any key leaks?
- Input validation?"
```

## Best Practices

1. **Start with project-overview** (always loaded)
2. **Switch contexts per task** (architecture ‚Üí implementation ‚Üí review)
3. **Be specific in prompts** ("Act as..." is implicit from context)
4. **Reference docs** (use @file to include files)
5. **Document decisions** (create ADRs for big choices)

## Context Combinations

Some tasks need multiple contexts:

**Group Feature Development:**
```
Day 1: architecture-lead + security-expert (design)
Day 2: react-native-expert + ui-designer (implement)
Day 3: xmpp-specialist (MUC integration)
Day 4: testing-qa (tests)
Day 5: performance-optimizer (optimize)
Day 6: documentation-writer (document)
```

## Tips

- **Quick switch**: Contexts load in ~5 seconds
- **Specific prompts**: "Following security-context, review encryption.ts"
- **Combine skills**: "As architecture lead, work with security expert to..."
- **Iterate**: Design ‚Üí Implement ‚Üí Test ‚Üí Optimize ‚Üí Document

## Support

Questions? Check:
- `docs/CommEazy_MVP_Plan_V1.0.md` - Full implementation plan
- `docs/Claude_Code_Setup_Guide.md` - Setup instructions
- Each context file has "Collaboration" section

---

**Ready to build CommEazy! üöÄ**
```

---

**EINDE VAN ALLE CONTEXT FILES**

Alle 10 context files zijn nu compleet!
---

# Context File 8: Testing & QA

**Bestand:** `.claude/07-testing-qa.md`

[COMPLETE TESTING CONTEXT FILE - SEE ABOVE IN OUTPUT]

---

# Context File 9: Performance Optimizer

**Bestand:** `.claude/08-performance-optimizer.md`

[COMPLETE PERFORMANCE CONTEXT FILE - SEE ABOVE IN OUTPUT]

---

# Context File 10: Documentation Writer

**Bestand:** `.claude/09-documentation-writer.md`

[COMPLETE DOCUMENTATION CONTEXT FILE - SEE ABOVE IN OUTPUT]

---

# Samenvatting: Alle 10 Context Files

## Complete Set Overview

| # | Bestand | Rol | Primaire Focus |
|---|---------|-----|----------------|
| 00 | project-overview.md | Master Context | Project missie, tech stack, altijd actief |
| 01 | architecture-lead.md | Lead Architect | System design, data flow, ADRs |
| 02 | security-expert.md | Security Expert | E2E encryption, zero storage, privacy |
| 03 | ui-designer.md | UI/UX Designer | Senior-friendly design, accessibility |
| 04 | ios-specialist.md | iOS Specialist | Native iOS, Xcode, App Store |
| 05 | react-native-expert.md | RN Expert | RN patterns, performance, state management |
| 06 | xmpp-specialist.md | XMPP Specialist | Prosody, MUC, zero storage protocol |
| 07 | testing-qa.md | QA Specialist | Unit/E2E tests, senior testing |
| 08 | performance-optimizer.md | Performance Expert | FlatList, images, memory, battery |
| 09 | documentation-writer.md | Documentation | JSDoc, ADRs, user guides |

## Usage Pattern in Xcode 26.3

**Week-by-week context selection:**

```
Week 1-4 (Foundation):
‚îú‚îÄ Primary: 01-architecture-lead.md
‚îú‚îÄ Secondary: 02-security-expert.md
‚îî‚îÄ Always: 00-project-overview.md

Week 5-8 (Core Features):
‚îú‚îÄ Primary: 05-react-native-expert.md
‚îú‚îÄ Secondary: 03-ui-designer.md
‚îî‚îÄ Always: 00-project-overview.md

Week 9-11 (Groups):
‚îú‚îÄ Primary: 06-xmpp-specialist.md
‚îú‚îÄ Secondary: 02-security-expert.md
‚îú‚îÄ Tertiary: 03-ui-designer.md
‚îî‚îÄ Always: 00-project-overview.md

Week 12-15 (Calls):
‚îú‚îÄ Primary: 04-ios-specialist.md
‚îú‚îÄ Secondary: 05-react-native-expert.md
‚îî‚îÄ Always: 00-project-overview.md

Week 16-19 (Polish):
‚îú‚îÄ Primary: 08-performance-optimizer.md
‚îú‚îÄ Secondary: 07-testing-qa.md
‚îî‚îÄ Always: 00-project-overview.md

Week 20-23 (Launch):
‚îú‚îÄ Primary: 07-testing-qa.md
‚îú‚îÄ Secondary: 09-documentation-writer.md
‚îî‚îÄ Always: 00-project-overview.md
```

## Best Practices

1. **Always load project-overview first** - Sets the foundation
2. **Load 2-3 contexts max** - Too many = confusion
3. **Switch contexts per task** - Don't keep all loaded
4. **Save context switches** - Document which contexts for which features
5. **Update contexts** - As project evolves, update context files

## Example Xcode 26.3 Workflow

```bash
# Morning: Design group chat architecture
> Claude: Load context 01-architecture-lead.md
> "Design the group message delivery architecture with outbox tracking"

# Afternoon: Implement shared-key encryption
> Claude: Load context 02-security-expert.md
> "Implement shared-key encryption for groups >8 members"

# Evening: Create group chat UI
> Claude: Load context 03-ui-designer.md
> "Create GroupChatScreen with senior-friendly design"

# Review: Security check
> Claude: Load context 02-security-expert.md
> "Security review: GroupChatScreen and encryption implementation"
```

---

**Ready to build CommEazy with Claude Code + Xcode 26.3! üöÄ**

